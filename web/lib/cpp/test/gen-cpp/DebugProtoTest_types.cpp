/**
 * Autogenerated by Thrift Compiler (1.0.0-dev)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "DebugProtoTest_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace thrift { namespace test { namespace debug {

int _kSomeEnumValues[] = {
  SomeEnum::ONE,
  SomeEnum::TWO
};
const char* _kSomeEnumNames[] = {
  "ONE",
  "TWO"
};
const std::map<int, const char*> _SomeEnum_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kSomeEnumValues, _kSomeEnumNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const SomeEnum::type& val) {
  std::map<int, const char*>::const_iterator it = _SomeEnum_VALUES_TO_NAMES.find(val);
  if (it != _SomeEnum_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}


Doubles::~Doubles() throw() {
}


void Doubles::__set_nan(const double val) {
  this->nan = val;
}

void Doubles::__set_inf(const double val) {
  this->inf = val;
}

void Doubles::__set_neginf(const double val) {
  this->neginf = val;
}

void Doubles::__set_repeating(const double val) {
  this->repeating = val;
}

void Doubles::__set_big(const double val) {
  this->big = val;
}

void Doubles::__set_tiny(const double val) {
  this->tiny = val;
}

void Doubles::__set_zero(const double val) {
  this->zero = val;
}

void Doubles::__set_negzero(const double val) {
  this->negzero = val;
}
std::ostream& operator<<(std::ostream& out, const Doubles& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Doubles::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->nan);
          this->__isset.nan = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->inf);
          this->__isset.inf = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->neginf);
          this->__isset.neginf = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->repeating);
          this->__isset.repeating = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->big);
          this->__isset.big = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->tiny);
          this->__isset.tiny = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->zero);
          this->__isset.zero = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->negzero);
          this->__isset.negzero = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Doubles::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Doubles");

  xfer += oprot->writeFieldBegin("nan", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->nan);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("inf", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->inf);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("neginf", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->neginf);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("repeating", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->repeating);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("big", ::apache::thrift::protocol::T_DOUBLE, 5);
  xfer += oprot->writeDouble(this->big);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tiny", ::apache::thrift::protocol::T_DOUBLE, 6);
  xfer += oprot->writeDouble(this->tiny);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("zero", ::apache::thrift::protocol::T_DOUBLE, 7);
  xfer += oprot->writeDouble(this->zero);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("negzero", ::apache::thrift::protocol::T_DOUBLE, 8);
  xfer += oprot->writeDouble(this->negzero);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Doubles &a, Doubles &b) {
  using ::std::swap;
  swap(a.nan, b.nan);
  swap(a.inf, b.inf);
  swap(a.neginf, b.neginf);
  swap(a.repeating, b.repeating);
  swap(a.big, b.big);
  swap(a.tiny, b.tiny);
  swap(a.zero, b.zero);
  swap(a.negzero, b.negzero);
  swap(a.__isset, b.__isset);
}

Doubles::Doubles(const Doubles& other0) {
  nan = other0.nan;
  inf = other0.inf;
  neginf = other0.neginf;
  repeating = other0.repeating;
  big = other0.big;
  tiny = other0.tiny;
  zero = other0.zero;
  negzero = other0.negzero;
  __isset = other0.__isset;
}
Doubles& Doubles::operator=(const Doubles& other1) {
  nan = other1.nan;
  inf = other1.inf;
  neginf = other1.neginf;
  repeating = other1.repeating;
  big = other1.big;
  tiny = other1.tiny;
  zero = other1.zero;
  negzero = other1.negzero;
  __isset = other1.__isset;
  return *this;
}
void Doubles::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Doubles(";
  out << "nan=" << to_string(nan);
  out << ", " << "inf=" << to_string(inf);
  out << ", " << "neginf=" << to_string(neginf);
  out << ", " << "repeating=" << to_string(repeating);
  out << ", " << "big=" << to_string(big);
  out << ", " << "tiny=" << to_string(tiny);
  out << ", " << "zero=" << to_string(zero);
  out << ", " << "negzero=" << to_string(negzero);
  out << ")";
}


OneOfEach::~OneOfEach() throw() {
}


void OneOfEach::__set_im_true(const bool val) {
  this->im_true = val;
}

void OneOfEach::__set_im_false(const bool val) {
  this->im_false = val;
}

void OneOfEach::__set_a_bite(const int8_t val) {
  this->a_bite = val;
}

void OneOfEach::__set_integer16(const int16_t val) {
  this->integer16 = val;
}

void OneOfEach::__set_integer32(const int32_t val) {
  this->integer32 = val;
}

void OneOfEach::__set_integer64(const int64_t val) {
  this->integer64 = val;
}

void OneOfEach::__set_double_precision(const double val) {
  this->double_precision = val;
}

void OneOfEach::__set_some_characters(const std::string& val) {
  this->some_characters = val;
}

void OneOfEach::__set_zomg_unicode(const std::string& val) {
  this->zomg_unicode = val;
}

void OneOfEach::__set_what_who(const bool val) {
  this->what_who = val;
}

void OneOfEach::__set_base64(const std::string& val) {
  this->base64 = val;
}

void OneOfEach::__set_byte_list(const std::vector<int8_t> & val) {
  this->byte_list = val;
}

void OneOfEach::__set_i16_list(const std::vector<int16_t> & val) {
  this->i16_list = val;
}

void OneOfEach::__set_i64_list(const std::vector<int64_t> & val) {
  this->i64_list = val;
}
std::ostream& operator<<(std::ostream& out, const OneOfEach& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t OneOfEach::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->im_true);
          this->__isset.im_true = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->im_false);
          this->__isset.im_false = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->a_bite);
          this->__isset.a_bite = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->integer16);
          this->__isset.integer16 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->integer32);
          this->__isset.integer32 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->integer64);
          this->__isset.integer64 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->double_precision);
          this->__isset.double_precision = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->some_characters);
          this->__isset.some_characters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->zomg_unicode);
          this->__isset.zomg_unicode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->what_who);
          this->__isset.what_who = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->base64);
          this->__isset.base64 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->byte_list.clear();
            uint32_t _size2;
            ::apache::thrift::protocol::TType _etype5;
            xfer += iprot->readListBegin(_etype5, _size2);
            this->byte_list.resize(_size2);
            uint32_t _i6;
            for (_i6 = 0; _i6 < _size2; ++_i6)
            {
              xfer += iprot->readByte(this->byte_list[_i6]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.byte_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->i16_list.clear();
            uint32_t _size7;
            ::apache::thrift::protocol::TType _etype10;
            xfer += iprot->readListBegin(_etype10, _size7);
            this->i16_list.resize(_size7);
            uint32_t _i11;
            for (_i11 = 0; _i11 < _size7; ++_i11)
            {
              xfer += iprot->readI16(this->i16_list[_i11]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.i16_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->i64_list.clear();
            uint32_t _size12;
            ::apache::thrift::protocol::TType _etype15;
            xfer += iprot->readListBegin(_etype15, _size12);
            this->i64_list.resize(_size12);
            uint32_t _i16;
            for (_i16 = 0; _i16 < _size12; ++_i16)
            {
              xfer += iprot->readI64(this->i64_list[_i16]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.i64_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t OneOfEach::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("OneOfEach");

  xfer += oprot->writeFieldBegin("im_true", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->im_true);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("im_false", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->im_false);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("a_bite", ::apache::thrift::protocol::T_BYTE, 3);
  xfer += oprot->writeByte(this->a_bite);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("integer16", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16(this->integer16);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("integer32", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->integer32);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("integer64", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->integer64);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("double_precision", ::apache::thrift::protocol::T_DOUBLE, 7);
  xfer += oprot->writeDouble(this->double_precision);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("some_characters", ::apache::thrift::protocol::T_STRING, 8);
  xfer += oprot->writeString(this->some_characters);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("zomg_unicode", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->zomg_unicode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("what_who", ::apache::thrift::protocol::T_BOOL, 10);
  xfer += oprot->writeBool(this->what_who);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("base64", ::apache::thrift::protocol::T_STRING, 11);
  xfer += oprot->writeBinary(this->base64);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("byte_list", ::apache::thrift::protocol::T_LIST, 12);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BYTE, static_cast<uint32_t>(this->byte_list.size()));
    std::vector<int8_t> ::const_iterator _iter17;
    for (_iter17 = this->byte_list.begin(); _iter17 != this->byte_list.end(); ++_iter17)
    {
      xfer += oprot->writeByte((*_iter17));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("i16_list", ::apache::thrift::protocol::T_LIST, 13);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>(this->i16_list.size()));
    std::vector<int16_t> ::const_iterator _iter18;
    for (_iter18 = this->i16_list.begin(); _iter18 != this->i16_list.end(); ++_iter18)
    {
      xfer += oprot->writeI16((*_iter18));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("i64_list", ::apache::thrift::protocol::T_LIST, 14);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->i64_list.size()));
    std::vector<int64_t> ::const_iterator _iter19;
    for (_iter19 = this->i64_list.begin(); _iter19 != this->i64_list.end(); ++_iter19)
    {
      xfer += oprot->writeI64((*_iter19));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(OneOfEach &a, OneOfEach &b) {
  using ::std::swap;
  swap(a.im_true, b.im_true);
  swap(a.im_false, b.im_false);
  swap(a.a_bite, b.a_bite);
  swap(a.integer16, b.integer16);
  swap(a.integer32, b.integer32);
  swap(a.integer64, b.integer64);
  swap(a.double_precision, b.double_precision);
  swap(a.some_characters, b.some_characters);
  swap(a.zomg_unicode, b.zomg_unicode);
  swap(a.what_who, b.what_who);
  swap(a.base64, b.base64);
  swap(a.byte_list, b.byte_list);
  swap(a.i16_list, b.i16_list);
  swap(a.i64_list, b.i64_list);
  swap(a.__isset, b.__isset);
}

OneOfEach::OneOfEach(const OneOfEach& other20) {
  im_true = other20.im_true;
  im_false = other20.im_false;
  a_bite = other20.a_bite;
  integer16 = other20.integer16;
  integer32 = other20.integer32;
  integer64 = other20.integer64;
  double_precision = other20.double_precision;
  some_characters = other20.some_characters;
  zomg_unicode = other20.zomg_unicode;
  what_who = other20.what_who;
  base64 = other20.base64;
  byte_list = other20.byte_list;
  i16_list = other20.i16_list;
  i64_list = other20.i64_list;
  __isset = other20.__isset;
}
OneOfEach& OneOfEach::operator=(const OneOfEach& other21) {
  im_true = other21.im_true;
  im_false = other21.im_false;
  a_bite = other21.a_bite;
  integer16 = other21.integer16;
  integer32 = other21.integer32;
  integer64 = other21.integer64;
  double_precision = other21.double_precision;
  some_characters = other21.some_characters;
  zomg_unicode = other21.zomg_unicode;
  what_who = other21.what_who;
  base64 = other21.base64;
  byte_list = other21.byte_list;
  i16_list = other21.i16_list;
  i64_list = other21.i64_list;
  __isset = other21.__isset;
  return *this;
}
void OneOfEach::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "OneOfEach(";
  out << "im_true=" << to_string(im_true);
  out << ", " << "im_false=" << to_string(im_false);
  out << ", " << "a_bite=" << to_string(a_bite);
  out << ", " << "integer16=" << to_string(integer16);
  out << ", " << "integer32=" << to_string(integer32);
  out << ", " << "integer64=" << to_string(integer64);
  out << ", " << "double_precision=" << to_string(double_precision);
  out << ", " << "some_characters=" << to_string(some_characters);
  out << ", " << "zomg_unicode=" << to_string(zomg_unicode);
  out << ", " << "what_who=" << to_string(what_who);
  out << ", " << "base64=" << to_string(base64);
  out << ", " << "byte_list=" << to_string(byte_list);
  out << ", " << "i16_list=" << to_string(i16_list);
  out << ", " << "i64_list=" << to_string(i64_list);
  out << ")";
}


Bonk::~Bonk() throw() {
}


void Bonk::__set_type(const int32_t val) {
  this->type = val;
}

void Bonk::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const Bonk& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Bonk::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Bonk::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Bonk");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Bonk &a, Bonk &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

Bonk::Bonk(const Bonk& other22) {
  type = other22.type;
  message = other22.message;
  __isset = other22.__isset;
}
Bonk& Bonk::operator=(const Bonk& other23) {
  type = other23.type;
  message = other23.message;
  __isset = other23.__isset;
  return *this;
}
void Bonk::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Bonk(";
  out << "type=" << to_string(type);
  out << ", " << "message=" << to_string(message);
  out << ")";
}


Nesting::~Nesting() throw() {
}


void Nesting::__set_my_bonk(const Bonk& val) {
  this->my_bonk = val;
}

void Nesting::__set_my_ooe(const OneOfEach& val) {
  this->my_ooe = val;
}
std::ostream& operator<<(std::ostream& out, const Nesting& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Nesting::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->my_bonk.read(iprot);
          this->__isset.my_bonk = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->my_ooe.read(iprot);
          this->__isset.my_ooe = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Nesting::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Nesting");

  xfer += oprot->writeFieldBegin("my_bonk", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->my_bonk.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("my_ooe", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->my_ooe.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Nesting &a, Nesting &b) {
  using ::std::swap;
  swap(a.my_bonk, b.my_bonk);
  swap(a.my_ooe, b.my_ooe);
  swap(a.__isset, b.__isset);
}

Nesting::Nesting(const Nesting& other24) {
  my_bonk = other24.my_bonk;
  my_ooe = other24.my_ooe;
  __isset = other24.__isset;
}
Nesting& Nesting::operator=(const Nesting& other25) {
  my_bonk = other25.my_bonk;
  my_ooe = other25.my_ooe;
  __isset = other25.__isset;
  return *this;
}
void Nesting::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Nesting(";
  out << "my_bonk=" << to_string(my_bonk);
  out << ", " << "my_ooe=" << to_string(my_ooe);
  out << ")";
}


HolyMoley::~HolyMoley() throw() {
}


void HolyMoley::__set_big(const std::vector<OneOfEach> & val) {
  this->big = val;
}

void HolyMoley::__set_contain(const std::set<std::vector<std::string> > & val) {
  this->contain = val;
}

void HolyMoley::__set_bonks(const std::map<std::string, std::vector<Bonk> > & val) {
  this->bonks = val;
}
std::ostream& operator<<(std::ostream& out, const HolyMoley& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t HolyMoley::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->big.clear();
            uint32_t _size26;
            ::apache::thrift::protocol::TType _etype29;
            xfer += iprot->readListBegin(_etype29, _size26);
            this->big.resize(_size26);
            uint32_t _i30;
            for (_i30 = 0; _i30 < _size26; ++_i30)
            {
              xfer += this->big[_i30].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.big = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->contain.clear();
            uint32_t _size31;
            ::apache::thrift::protocol::TType _etype34;
            xfer += iprot->readSetBegin(_etype34, _size31);
            uint32_t _i35;
            for (_i35 = 0; _i35 < _size31; ++_i35)
            {
              std::vector<std::string>  _elem36;
              {
                _elem36.clear();
                uint32_t _size37;
                ::apache::thrift::protocol::TType _etype40;
                xfer += iprot->readListBegin(_etype40, _size37);
                _elem36.resize(_size37);
                uint32_t _i41;
                for (_i41 = 0; _i41 < _size37; ++_i41)
                {
                  xfer += iprot->readString(_elem36[_i41]);
                }
                xfer += iprot->readListEnd();
              }
              this->contain.insert(_elem36);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.contain = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->bonks.clear();
            uint32_t _size42;
            ::apache::thrift::protocol::TType _ktype43;
            ::apache::thrift::protocol::TType _vtype44;
            xfer += iprot->readMapBegin(_ktype43, _vtype44, _size42);
            uint32_t _i46;
            for (_i46 = 0; _i46 < _size42; ++_i46)
            {
              std::string _key47;
              xfer += iprot->readString(_key47);
              std::vector<Bonk> & _val48 = this->bonks[_key47];
              {
                _val48.clear();
                uint32_t _size49;
                ::apache::thrift::protocol::TType _etype52;
                xfer += iprot->readListBegin(_etype52, _size49);
                _val48.resize(_size49);
                uint32_t _i53;
                for (_i53 = 0; _i53 < _size49; ++_i53)
                {
                  xfer += _val48[_i53].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.bonks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HolyMoley::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HolyMoley");

  xfer += oprot->writeFieldBegin("big", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->big.size()));
    std::vector<OneOfEach> ::const_iterator _iter54;
    for (_iter54 = this->big.begin(); _iter54 != this->big.end(); ++_iter54)
    {
      xfer += (*_iter54).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("contain", ::apache::thrift::protocol::T_SET, 2);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->contain.size()));
    std::set<std::vector<std::string> > ::const_iterator _iter55;
    for (_iter55 = this->contain.begin(); _iter55 != this->contain.end(); ++_iter55)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*_iter55).size()));
        std::vector<std::string> ::const_iterator _iter56;
        for (_iter56 = (*_iter55).begin(); _iter56 != (*_iter55).end(); ++_iter56)
        {
          xfer += oprot->writeString((*_iter56));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bonks", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->bonks.size()));
    std::map<std::string, std::vector<Bonk> > ::const_iterator _iter57;
    for (_iter57 = this->bonks.begin(); _iter57 != this->bonks.end(); ++_iter57)
    {
      xfer += oprot->writeString(_iter57->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter57->second.size()));
        std::vector<Bonk> ::const_iterator _iter58;
        for (_iter58 = _iter57->second.begin(); _iter58 != _iter57->second.end(); ++_iter58)
        {
          xfer += (*_iter58).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HolyMoley &a, HolyMoley &b) {
  using ::std::swap;
  swap(a.big, b.big);
  swap(a.contain, b.contain);
  swap(a.bonks, b.bonks);
  swap(a.__isset, b.__isset);
}

HolyMoley::HolyMoley(const HolyMoley& other59) {
  big = other59.big;
  contain = other59.contain;
  bonks = other59.bonks;
  __isset = other59.__isset;
}
HolyMoley& HolyMoley::operator=(const HolyMoley& other60) {
  big = other60.big;
  contain = other60.contain;
  bonks = other60.bonks;
  __isset = other60.__isset;
  return *this;
}
void HolyMoley::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "HolyMoley(";
  out << "big=" << to_string(big);
  out << ", " << "contain=" << to_string(contain);
  out << ", " << "bonks=" << to_string(bonks);
  out << ")";
}


Backwards::~Backwards() throw() {
}


void Backwards::__set_first_tag2(const int32_t val) {
  this->first_tag2 = val;
}

void Backwards::__set_second_tag1(const int32_t val) {
  this->second_tag1 = val;
}
std::ostream& operator<<(std::ostream& out, const Backwards& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Backwards::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->first_tag2);
          this->__isset.first_tag2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->second_tag1);
          this->__isset.second_tag1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Backwards::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Backwards");

  xfer += oprot->writeFieldBegin("second_tag1", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->second_tag1);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("first_tag2", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->first_tag2);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Backwards &a, Backwards &b) {
  using ::std::swap;
  swap(a.first_tag2, b.first_tag2);
  swap(a.second_tag1, b.second_tag1);
  swap(a.__isset, b.__isset);
}

Backwards::Backwards(const Backwards& other61) {
  first_tag2 = other61.first_tag2;
  second_tag1 = other61.second_tag1;
  __isset = other61.__isset;
}
Backwards& Backwards::operator=(const Backwards& other62) {
  first_tag2 = other62.first_tag2;
  second_tag1 = other62.second_tag1;
  __isset = other62.__isset;
  return *this;
}
void Backwards::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Backwards(";
  out << "first_tag2=" << to_string(first_tag2);
  out << ", " << "second_tag1=" << to_string(second_tag1);
  out << ")";
}


Empty::~Empty() throw() {
}

std::ostream& operator<<(std::ostream& out, const Empty& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Empty::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Empty::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Empty");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Empty &a, Empty &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

Empty::Empty(const Empty& other63) {
  (void) other63;
}
Empty& Empty::operator=(const Empty& other64) {
  (void) other64;
  return *this;
}
void Empty::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Empty(";
  out << ")";
}


Wrapper::~Wrapper() throw() {
}


void Wrapper::__set_foo(const Empty& val) {
  this->foo = val;
}
std::ostream& operator<<(std::ostream& out, const Wrapper& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Wrapper::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->foo.read(iprot);
          this->__isset.foo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Wrapper::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Wrapper");

  xfer += oprot->writeFieldBegin("foo", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->foo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Wrapper &a, Wrapper &b) {
  using ::std::swap;
  swap(a.foo, b.foo);
  swap(a.__isset, b.__isset);
}

Wrapper::Wrapper(const Wrapper& other65) {
  foo = other65.foo;
  __isset = other65.__isset;
}
Wrapper& Wrapper::operator=(const Wrapper& other66) {
  foo = other66.foo;
  __isset = other66.__isset;
  return *this;
}
void Wrapper::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Wrapper(";
  out << "foo=" << to_string(foo);
  out << ")";
}


RandomStuff::~RandomStuff() throw() {
}


void RandomStuff::__set_a(const int32_t val) {
  this->a = val;
}

void RandomStuff::__set_b(const int32_t val) {
  this->b = val;
}

void RandomStuff::__set_c(const int32_t val) {
  this->c = val;
}

void RandomStuff::__set_d(const int32_t val) {
  this->d = val;
}

void RandomStuff::__set_myintlist(const std::vector<int32_t> & val) {
  this->myintlist = val;
}

void RandomStuff::__set_maps(const std::map<int32_t, Wrapper> & val) {
  this->maps = val;
}

void RandomStuff::__set_bigint(const int64_t val) {
  this->bigint = val;
}

void RandomStuff::__set_triple(const double val) {
  this->triple = val;
}
std::ostream& operator<<(std::ostream& out, const RandomStuff& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t RandomStuff::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->a);
          this->__isset.a = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->b);
          this->__isset.b = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->c);
          this->__isset.c = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->d);
          this->__isset.d = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->myintlist.clear();
            uint32_t _size67;
            ::apache::thrift::protocol::TType _etype70;
            xfer += iprot->readListBegin(_etype70, _size67);
            this->myintlist.resize(_size67);
            uint32_t _i71;
            for (_i71 = 0; _i71 < _size67; ++_i71)
            {
              xfer += iprot->readI32(this->myintlist[_i71]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.myintlist = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->maps.clear();
            uint32_t _size72;
            ::apache::thrift::protocol::TType _ktype73;
            ::apache::thrift::protocol::TType _vtype74;
            xfer += iprot->readMapBegin(_ktype73, _vtype74, _size72);
            uint32_t _i76;
            for (_i76 = 0; _i76 < _size72; ++_i76)
            {
              int32_t _key77;
              xfer += iprot->readI32(_key77);
              Wrapper& _val78 = this->maps[_key77];
              xfer += _val78.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.maps = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->bigint);
          this->__isset.bigint = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->triple);
          this->__isset.triple = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RandomStuff::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RandomStuff");

  xfer += oprot->writeFieldBegin("a", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->a);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("b", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->b);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("c", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->c);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("d", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->d);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("myintlist", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->myintlist.size()));
    std::vector<int32_t> ::const_iterator _iter79;
    for (_iter79 = this->myintlist.begin(); _iter79 != this->myintlist.end(); ++_iter79)
    {
      xfer += oprot->writeI32((*_iter79));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maps", ::apache::thrift::protocol::T_MAP, 6);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->maps.size()));
    std::map<int32_t, Wrapper> ::const_iterator _iter80;
    for (_iter80 = this->maps.begin(); _iter80 != this->maps.end(); ++_iter80)
    {
      xfer += oprot->writeI32(_iter80->first);
      xfer += _iter80->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bigint", ::apache::thrift::protocol::T_I64, 7);
  xfer += oprot->writeI64(this->bigint);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("triple", ::apache::thrift::protocol::T_DOUBLE, 8);
  xfer += oprot->writeDouble(this->triple);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RandomStuff &a, RandomStuff &b) {
  using ::std::swap;
  swap(a.a, b.a);
  swap(a.b, b.b);
  swap(a.c, b.c);
  swap(a.d, b.d);
  swap(a.myintlist, b.myintlist);
  swap(a.maps, b.maps);
  swap(a.bigint, b.bigint);
  swap(a.triple, b.triple);
  swap(a.__isset, b.__isset);
}

RandomStuff::RandomStuff(const RandomStuff& other81) {
  a = other81.a;
  b = other81.b;
  c = other81.c;
  d = other81.d;
  myintlist = other81.myintlist;
  maps = other81.maps;
  bigint = other81.bigint;
  triple = other81.triple;
  __isset = other81.__isset;
}
RandomStuff& RandomStuff::operator=(const RandomStuff& other82) {
  a = other82.a;
  b = other82.b;
  c = other82.c;
  d = other82.d;
  myintlist = other82.myintlist;
  maps = other82.maps;
  bigint = other82.bigint;
  triple = other82.triple;
  __isset = other82.__isset;
  return *this;
}
void RandomStuff::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RandomStuff(";
  out << "a=" << to_string(a);
  out << ", " << "b=" << to_string(b);
  out << ", " << "c=" << to_string(c);
  out << ", " << "d=" << to_string(d);
  out << ", " << "myintlist=" << to_string(myintlist);
  out << ", " << "maps=" << to_string(maps);
  out << ", " << "bigint=" << to_string(bigint);
  out << ", " << "triple=" << to_string(triple);
  out << ")";
}


Base64::~Base64() throw() {
}


void Base64::__set_a(const int32_t val) {
  this->a = val;
}

void Base64::__set_b1(const std::string& val) {
  this->b1 = val;
}

void Base64::__set_b2(const std::string& val) {
  this->b2 = val;
}

void Base64::__set_b3(const std::string& val) {
  this->b3 = val;
}

void Base64::__set_b4(const std::string& val) {
  this->b4 = val;
}

void Base64::__set_b5(const std::string& val) {
  this->b5 = val;
}

void Base64::__set_b6(const std::string& val) {
  this->b6 = val;
}
std::ostream& operator<<(std::ostream& out, const Base64& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Base64::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->a);
          this->__isset.a = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->b1);
          this->__isset.b1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->b2);
          this->__isset.b2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->b3);
          this->__isset.b3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->b4);
          this->__isset.b4 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->b5);
          this->__isset.b5 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->b6);
          this->__isset.b6 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Base64::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Base64");

  xfer += oprot->writeFieldBegin("a", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->a);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("b1", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->b1);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("b2", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->b2);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("b3", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->b3);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("b4", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeBinary(this->b4);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("b5", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeBinary(this->b5);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("b6", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeBinary(this->b6);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Base64 &a, Base64 &b) {
  using ::std::swap;
  swap(a.a, b.a);
  swap(a.b1, b.b1);
  swap(a.b2, b.b2);
  swap(a.b3, b.b3);
  swap(a.b4, b.b4);
  swap(a.b5, b.b5);
  swap(a.b6, b.b6);
  swap(a.__isset, b.__isset);
}

Base64::Base64(const Base64& other83) {
  a = other83.a;
  b1 = other83.b1;
  b2 = other83.b2;
  b3 = other83.b3;
  b4 = other83.b4;
  b5 = other83.b5;
  b6 = other83.b6;
  __isset = other83.__isset;
}
Base64& Base64::operator=(const Base64& other84) {
  a = other84.a;
  b1 = other84.b1;
  b2 = other84.b2;
  b3 = other84.b3;
  b4 = other84.b4;
  b5 = other84.b5;
  b6 = other84.b6;
  __isset = other84.__isset;
  return *this;
}
void Base64::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Base64(";
  out << "a=" << to_string(a);
  out << ", " << "b1=" << to_string(b1);
  out << ", " << "b2=" << to_string(b2);
  out << ", " << "b3=" << to_string(b3);
  out << ", " << "b4=" << to_string(b4);
  out << ", " << "b5=" << to_string(b5);
  out << ", " << "b6=" << to_string(b6);
  out << ")";
}


CompactProtoTestStruct::~CompactProtoTestStruct() throw() {
}


void CompactProtoTestStruct::__set_a_byte(const int8_t val) {
  this->a_byte = val;
}

void CompactProtoTestStruct::__set_a_i16(const int16_t val) {
  this->a_i16 = val;
}

void CompactProtoTestStruct::__set_a_i32(const int32_t val) {
  this->a_i32 = val;
}

void CompactProtoTestStruct::__set_a_i64(const int64_t val) {
  this->a_i64 = val;
}

void CompactProtoTestStruct::__set_a_double(const double val) {
  this->a_double = val;
}

void CompactProtoTestStruct::__set_a_string(const std::string& val) {
  this->a_string = val;
}

void CompactProtoTestStruct::__set_a_binary(const std::string& val) {
  this->a_binary = val;
}

void CompactProtoTestStruct::__set_true_field(const bool val) {
  this->true_field = val;
}

void CompactProtoTestStruct::__set_false_field(const bool val) {
  this->false_field = val;
}

void CompactProtoTestStruct::__set_empty_struct_field(const Empty& val) {
  this->empty_struct_field = val;
}

void CompactProtoTestStruct::__set_byte_list(const std::vector<int8_t> & val) {
  this->byte_list = val;
}

void CompactProtoTestStruct::__set_i16_list(const std::vector<int16_t> & val) {
  this->i16_list = val;
}

void CompactProtoTestStruct::__set_i32_list(const std::vector<int32_t> & val) {
  this->i32_list = val;
}

void CompactProtoTestStruct::__set_i64_list(const std::vector<int64_t> & val) {
  this->i64_list = val;
}

void CompactProtoTestStruct::__set_double_list(const std::vector<double> & val) {
  this->double_list = val;
}

void CompactProtoTestStruct::__set_string_list(const std::vector<std::string> & val) {
  this->string_list = val;
}

void CompactProtoTestStruct::__set_binary_list(const std::vector<std::string> & val) {
  this->binary_list = val;
}

void CompactProtoTestStruct::__set_boolean_list(const std::vector<bool> & val) {
  this->boolean_list = val;
}

void CompactProtoTestStruct::__set_struct_list(const std::vector<Empty> & val) {
  this->struct_list = val;
}

void CompactProtoTestStruct::__set_byte_set(const std::set<int8_t> & val) {
  this->byte_set = val;
}

void CompactProtoTestStruct::__set_i16_set(const std::set<int16_t> & val) {
  this->i16_set = val;
}

void CompactProtoTestStruct::__set_i32_set(const std::set<int32_t> & val) {
  this->i32_set = val;
}

void CompactProtoTestStruct::__set_i64_set(const std::set<int64_t> & val) {
  this->i64_set = val;
}

void CompactProtoTestStruct::__set_double_set(const std::set<double> & val) {
  this->double_set = val;
}

void CompactProtoTestStruct::__set_string_set(const std::set<std::string> & val) {
  this->string_set = val;
}

void CompactProtoTestStruct::__set_binary_set(const std::set<std::string> & val) {
  this->binary_set = val;
}

void CompactProtoTestStruct::__set_boolean_set(const std::set<bool> & val) {
  this->boolean_set = val;
}

void CompactProtoTestStruct::__set_struct_set(const std::set<Empty> & val) {
  this->struct_set = val;
}

void CompactProtoTestStruct::__set_byte_byte_map(const std::map<int8_t, int8_t> & val) {
  this->byte_byte_map = val;
}

void CompactProtoTestStruct::__set_i16_byte_map(const std::map<int16_t, int8_t> & val) {
  this->i16_byte_map = val;
}

void CompactProtoTestStruct::__set_i32_byte_map(const std::map<int32_t, int8_t> & val) {
  this->i32_byte_map = val;
}

void CompactProtoTestStruct::__set_i64_byte_map(const std::map<int64_t, int8_t> & val) {
  this->i64_byte_map = val;
}

void CompactProtoTestStruct::__set_double_byte_map(const std::map<double, int8_t> & val) {
  this->double_byte_map = val;
}

void CompactProtoTestStruct::__set_string_byte_map(const std::map<std::string, int8_t> & val) {
  this->string_byte_map = val;
}

void CompactProtoTestStruct::__set_binary_byte_map(const std::map<std::string, int8_t> & val) {
  this->binary_byte_map = val;
}

void CompactProtoTestStruct::__set_boolean_byte_map(const std::map<bool, int8_t> & val) {
  this->boolean_byte_map = val;
}

void CompactProtoTestStruct::__set_byte_i16_map(const std::map<int8_t, int16_t> & val) {
  this->byte_i16_map = val;
}

void CompactProtoTestStruct::__set_byte_i32_map(const std::map<int8_t, int32_t> & val) {
  this->byte_i32_map = val;
}

void CompactProtoTestStruct::__set_byte_i64_map(const std::map<int8_t, int64_t> & val) {
  this->byte_i64_map = val;
}

void CompactProtoTestStruct::__set_byte_double_map(const std::map<int8_t, double> & val) {
  this->byte_double_map = val;
}

void CompactProtoTestStruct::__set_byte_string_map(const std::map<int8_t, std::string> & val) {
  this->byte_string_map = val;
}

void CompactProtoTestStruct::__set_byte_binary_map(const std::map<int8_t, std::string> & val) {
  this->byte_binary_map = val;
}

void CompactProtoTestStruct::__set_byte_boolean_map(const std::map<int8_t, bool> & val) {
  this->byte_boolean_map = val;
}

void CompactProtoTestStruct::__set_list_byte_map(const std::map<std::vector<int8_t> , int8_t> & val) {
  this->list_byte_map = val;
}

void CompactProtoTestStruct::__set_set_byte_map(const std::map<std::set<int8_t> , int8_t> & val) {
  this->set_byte_map = val;
}

void CompactProtoTestStruct::__set_map_byte_map(const std::map<std::map<int8_t, int8_t> , int8_t> & val) {
  this->map_byte_map = val;
}

void CompactProtoTestStruct::__set_byte_map_map(const std::map<int8_t, std::map<int8_t, int8_t> > & val) {
  this->byte_map_map = val;
}

void CompactProtoTestStruct::__set_byte_set_map(const std::map<int8_t, std::set<int8_t> > & val) {
  this->byte_set_map = val;
}

void CompactProtoTestStruct::__set_byte_list_map(const std::map<int8_t, std::vector<int8_t> > & val) {
  this->byte_list_map = val;
}
std::ostream& operator<<(std::ostream& out, const CompactProtoTestStruct& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CompactProtoTestStruct::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->a_byte);
          this->__isset.a_byte = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->a_i16);
          this->__isset.a_i16 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->a_i32);
          this->__isset.a_i32 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->a_i64);
          this->__isset.a_i64 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->a_double);
          this->__isset.a_double = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->a_string);
          this->__isset.a_string = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->a_binary);
          this->__isset.a_binary = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->true_field);
          this->__isset.true_field = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->false_field);
          this->__isset.false_field = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->empty_struct_field.read(iprot);
          this->__isset.empty_struct_field = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->byte_list.clear();
            uint32_t _size85;
            ::apache::thrift::protocol::TType _etype88;
            xfer += iprot->readListBegin(_etype88, _size85);
            this->byte_list.resize(_size85);
            uint32_t _i89;
            for (_i89 = 0; _i89 < _size85; ++_i89)
            {
              xfer += iprot->readByte(this->byte_list[_i89]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.byte_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->i16_list.clear();
            uint32_t _size90;
            ::apache::thrift::protocol::TType _etype93;
            xfer += iprot->readListBegin(_etype93, _size90);
            this->i16_list.resize(_size90);
            uint32_t _i94;
            for (_i94 = 0; _i94 < _size90; ++_i94)
            {
              xfer += iprot->readI16(this->i16_list[_i94]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.i16_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->i32_list.clear();
            uint32_t _size95;
            ::apache::thrift::protocol::TType _etype98;
            xfer += iprot->readListBegin(_etype98, _size95);
            this->i32_list.resize(_size95);
            uint32_t _i99;
            for (_i99 = 0; _i99 < _size95; ++_i99)
            {
              xfer += iprot->readI32(this->i32_list[_i99]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.i32_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->i64_list.clear();
            uint32_t _size100;
            ::apache::thrift::protocol::TType _etype103;
            xfer += iprot->readListBegin(_etype103, _size100);
            this->i64_list.resize(_size100);
            uint32_t _i104;
            for (_i104 = 0; _i104 < _size100; ++_i104)
            {
              xfer += iprot->readI64(this->i64_list[_i104]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.i64_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->double_list.clear();
            uint32_t _size105;
            ::apache::thrift::protocol::TType _etype108;
            xfer += iprot->readListBegin(_etype108, _size105);
            this->double_list.resize(_size105);
            uint32_t _i109;
            for (_i109 = 0; _i109 < _size105; ++_i109)
            {
              xfer += iprot->readDouble(this->double_list[_i109]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.double_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->string_list.clear();
            uint32_t _size110;
            ::apache::thrift::protocol::TType _etype113;
            xfer += iprot->readListBegin(_etype113, _size110);
            this->string_list.resize(_size110);
            uint32_t _i114;
            for (_i114 = 0; _i114 < _size110; ++_i114)
            {
              xfer += iprot->readString(this->string_list[_i114]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.string_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->binary_list.clear();
            uint32_t _size115;
            ::apache::thrift::protocol::TType _etype118;
            xfer += iprot->readListBegin(_etype118, _size115);
            this->binary_list.resize(_size115);
            uint32_t _i119;
            for (_i119 = 0; _i119 < _size115; ++_i119)
            {
              xfer += iprot->readBinary(this->binary_list[_i119]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.binary_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->boolean_list.clear();
            uint32_t _size120;
            ::apache::thrift::protocol::TType _etype123;
            xfer += iprot->readListBegin(_etype123, _size120);
            this->boolean_list.resize(_size120);
            uint32_t _i124;
            for (_i124 = 0; _i124 < _size120; ++_i124)
            {
              xfer += iprot->readBool(this->boolean_list[_i124]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.boolean_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->struct_list.clear();
            uint32_t _size125;
            ::apache::thrift::protocol::TType _etype128;
            xfer += iprot->readListBegin(_etype128, _size125);
            this->struct_list.resize(_size125);
            uint32_t _i129;
            for (_i129 = 0; _i129 < _size125; ++_i129)
            {
              xfer += this->struct_list[_i129].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.struct_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->byte_set.clear();
            uint32_t _size130;
            ::apache::thrift::protocol::TType _etype133;
            xfer += iprot->readSetBegin(_etype133, _size130);
            uint32_t _i134;
            for (_i134 = 0; _i134 < _size130; ++_i134)
            {
              int8_t _elem135;
              xfer += iprot->readByte(_elem135);
              this->byte_set.insert(_elem135);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.byte_set = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->i16_set.clear();
            uint32_t _size136;
            ::apache::thrift::protocol::TType _etype139;
            xfer += iprot->readSetBegin(_etype139, _size136);
            uint32_t _i140;
            for (_i140 = 0; _i140 < _size136; ++_i140)
            {
              int16_t _elem141;
              xfer += iprot->readI16(_elem141);
              this->i16_set.insert(_elem141);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.i16_set = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->i32_set.clear();
            uint32_t _size142;
            ::apache::thrift::protocol::TType _etype145;
            xfer += iprot->readSetBegin(_etype145, _size142);
            uint32_t _i146;
            for (_i146 = 0; _i146 < _size142; ++_i146)
            {
              int32_t _elem147;
              xfer += iprot->readI32(_elem147);
              this->i32_set.insert(_elem147);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.i32_set = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->i64_set.clear();
            uint32_t _size148;
            ::apache::thrift::protocol::TType _etype151;
            xfer += iprot->readSetBegin(_etype151, _size148);
            uint32_t _i152;
            for (_i152 = 0; _i152 < _size148; ++_i152)
            {
              int64_t _elem153;
              xfer += iprot->readI64(_elem153);
              this->i64_set.insert(_elem153);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.i64_set = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->double_set.clear();
            uint32_t _size154;
            ::apache::thrift::protocol::TType _etype157;
            xfer += iprot->readSetBegin(_etype157, _size154);
            uint32_t _i158;
            for (_i158 = 0; _i158 < _size154; ++_i158)
            {
              double _elem159;
              xfer += iprot->readDouble(_elem159);
              this->double_set.insert(_elem159);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.double_set = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->string_set.clear();
            uint32_t _size160;
            ::apache::thrift::protocol::TType _etype163;
            xfer += iprot->readSetBegin(_etype163, _size160);
            uint32_t _i164;
            for (_i164 = 0; _i164 < _size160; ++_i164)
            {
              std::string _elem165;
              xfer += iprot->readString(_elem165);
              this->string_set.insert(_elem165);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.string_set = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 26:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->binary_set.clear();
            uint32_t _size166;
            ::apache::thrift::protocol::TType _etype169;
            xfer += iprot->readSetBegin(_etype169, _size166);
            uint32_t _i170;
            for (_i170 = 0; _i170 < _size166; ++_i170)
            {
              std::string _elem171;
              xfer += iprot->readBinary(_elem171);
              this->binary_set.insert(_elem171);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.binary_set = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 27:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->boolean_set.clear();
            uint32_t _size172;
            ::apache::thrift::protocol::TType _etype175;
            xfer += iprot->readSetBegin(_etype175, _size172);
            uint32_t _i176;
            for (_i176 = 0; _i176 < _size172; ++_i176)
            {
              bool _elem177;
              xfer += iprot->readBool(_elem177);
              this->boolean_set.insert(_elem177);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.boolean_set = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 28:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->struct_set.clear();
            uint32_t _size178;
            ::apache::thrift::protocol::TType _etype181;
            xfer += iprot->readSetBegin(_etype181, _size178);
            uint32_t _i182;
            for (_i182 = 0; _i182 < _size178; ++_i182)
            {
              Empty _elem183;
              xfer += _elem183.read(iprot);
              this->struct_set.insert(_elem183);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.struct_set = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 29:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->byte_byte_map.clear();
            uint32_t _size184;
            ::apache::thrift::protocol::TType _ktype185;
            ::apache::thrift::protocol::TType _vtype186;
            xfer += iprot->readMapBegin(_ktype185, _vtype186, _size184);
            uint32_t _i188;
            for (_i188 = 0; _i188 < _size184; ++_i188)
            {
              int8_t _key189;
              xfer += iprot->readByte(_key189);
              int8_t& _val190 = this->byte_byte_map[_key189];
              xfer += iprot->readByte(_val190);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.byte_byte_map = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->i16_byte_map.clear();
            uint32_t _size191;
            ::apache::thrift::protocol::TType _ktype192;
            ::apache::thrift::protocol::TType _vtype193;
            xfer += iprot->readMapBegin(_ktype192, _vtype193, _size191);
            uint32_t _i195;
            for (_i195 = 0; _i195 < _size191; ++_i195)
            {
              int16_t _key196;
              xfer += iprot->readI16(_key196);
              int8_t& _val197 = this->i16_byte_map[_key196];
              xfer += iprot->readByte(_val197);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.i16_byte_map = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 31:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->i32_byte_map.clear();
            uint32_t _size198;
            ::apache::thrift::protocol::TType _ktype199;
            ::apache::thrift::protocol::TType _vtype200;
            xfer += iprot->readMapBegin(_ktype199, _vtype200, _size198);
            uint32_t _i202;
            for (_i202 = 0; _i202 < _size198; ++_i202)
            {
              int32_t _key203;
              xfer += iprot->readI32(_key203);
              int8_t& _val204 = this->i32_byte_map[_key203];
              xfer += iprot->readByte(_val204);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.i32_byte_map = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 32:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->i64_byte_map.clear();
            uint32_t _size205;
            ::apache::thrift::protocol::TType _ktype206;
            ::apache::thrift::protocol::TType _vtype207;
            xfer += iprot->readMapBegin(_ktype206, _vtype207, _size205);
            uint32_t _i209;
            for (_i209 = 0; _i209 < _size205; ++_i209)
            {
              int64_t _key210;
              xfer += iprot->readI64(_key210);
              int8_t& _val211 = this->i64_byte_map[_key210];
              xfer += iprot->readByte(_val211);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.i64_byte_map = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 33:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->double_byte_map.clear();
            uint32_t _size212;
            ::apache::thrift::protocol::TType _ktype213;
            ::apache::thrift::protocol::TType _vtype214;
            xfer += iprot->readMapBegin(_ktype213, _vtype214, _size212);
            uint32_t _i216;
            for (_i216 = 0; _i216 < _size212; ++_i216)
            {
              double _key217;
              xfer += iprot->readDouble(_key217);
              int8_t& _val218 = this->double_byte_map[_key217];
              xfer += iprot->readByte(_val218);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.double_byte_map = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 34:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->string_byte_map.clear();
            uint32_t _size219;
            ::apache::thrift::protocol::TType _ktype220;
            ::apache::thrift::protocol::TType _vtype221;
            xfer += iprot->readMapBegin(_ktype220, _vtype221, _size219);
            uint32_t _i223;
            for (_i223 = 0; _i223 < _size219; ++_i223)
            {
              std::string _key224;
              xfer += iprot->readString(_key224);
              int8_t& _val225 = this->string_byte_map[_key224];
              xfer += iprot->readByte(_val225);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.string_byte_map = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 35:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->binary_byte_map.clear();
            uint32_t _size226;
            ::apache::thrift::protocol::TType _ktype227;
            ::apache::thrift::protocol::TType _vtype228;
            xfer += iprot->readMapBegin(_ktype227, _vtype228, _size226);
            uint32_t _i230;
            for (_i230 = 0; _i230 < _size226; ++_i230)
            {
              std::string _key231;
              xfer += iprot->readBinary(_key231);
              int8_t& _val232 = this->binary_byte_map[_key231];
              xfer += iprot->readByte(_val232);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.binary_byte_map = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 36:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->boolean_byte_map.clear();
            uint32_t _size233;
            ::apache::thrift::protocol::TType _ktype234;
            ::apache::thrift::protocol::TType _vtype235;
            xfer += iprot->readMapBegin(_ktype234, _vtype235, _size233);
            uint32_t _i237;
            for (_i237 = 0; _i237 < _size233; ++_i237)
            {
              bool _key238;
              xfer += iprot->readBool(_key238);
              int8_t& _val239 = this->boolean_byte_map[_key238];
              xfer += iprot->readByte(_val239);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.boolean_byte_map = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 37:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->byte_i16_map.clear();
            uint32_t _size240;
            ::apache::thrift::protocol::TType _ktype241;
            ::apache::thrift::protocol::TType _vtype242;
            xfer += iprot->readMapBegin(_ktype241, _vtype242, _size240);
            uint32_t _i244;
            for (_i244 = 0; _i244 < _size240; ++_i244)
            {
              int8_t _key245;
              xfer += iprot->readByte(_key245);
              int16_t& _val246 = this->byte_i16_map[_key245];
              xfer += iprot->readI16(_val246);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.byte_i16_map = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 38:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->byte_i32_map.clear();
            uint32_t _size247;
            ::apache::thrift::protocol::TType _ktype248;
            ::apache::thrift::protocol::TType _vtype249;
            xfer += iprot->readMapBegin(_ktype248, _vtype249, _size247);
            uint32_t _i251;
            for (_i251 = 0; _i251 < _size247; ++_i251)
            {
              int8_t _key252;
              xfer += iprot->readByte(_key252);
              int32_t& _val253 = this->byte_i32_map[_key252];
              xfer += iprot->readI32(_val253);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.byte_i32_map = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 39:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->byte_i64_map.clear();
            uint32_t _size254;
            ::apache::thrift::protocol::TType _ktype255;
            ::apache::thrift::protocol::TType _vtype256;
            xfer += iprot->readMapBegin(_ktype255, _vtype256, _size254);
            uint32_t _i258;
            for (_i258 = 0; _i258 < _size254; ++_i258)
            {
              int8_t _key259;
              xfer += iprot->readByte(_key259);
              int64_t& _val260 = this->byte_i64_map[_key259];
              xfer += iprot->readI64(_val260);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.byte_i64_map = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->byte_double_map.clear();
            uint32_t _size261;
            ::apache::thrift::protocol::TType _ktype262;
            ::apache::thrift::protocol::TType _vtype263;
            xfer += iprot->readMapBegin(_ktype262, _vtype263, _size261);
            uint32_t _i265;
            for (_i265 = 0; _i265 < _size261; ++_i265)
            {
              int8_t _key266;
              xfer += iprot->readByte(_key266);
              double& _val267 = this->byte_double_map[_key266];
              xfer += iprot->readDouble(_val267);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.byte_double_map = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 41:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->byte_string_map.clear();
            uint32_t _size268;
            ::apache::thrift::protocol::TType _ktype269;
            ::apache::thrift::protocol::TType _vtype270;
            xfer += iprot->readMapBegin(_ktype269, _vtype270, _size268);
            uint32_t _i272;
            for (_i272 = 0; _i272 < _size268; ++_i272)
            {
              int8_t _key273;
              xfer += iprot->readByte(_key273);
              std::string& _val274 = this->byte_string_map[_key273];
              xfer += iprot->readString(_val274);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.byte_string_map = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 42:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->byte_binary_map.clear();
            uint32_t _size275;
            ::apache::thrift::protocol::TType _ktype276;
            ::apache::thrift::protocol::TType _vtype277;
            xfer += iprot->readMapBegin(_ktype276, _vtype277, _size275);
            uint32_t _i279;
            for (_i279 = 0; _i279 < _size275; ++_i279)
            {
              int8_t _key280;
              xfer += iprot->readByte(_key280);
              std::string& _val281 = this->byte_binary_map[_key280];
              xfer += iprot->readBinary(_val281);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.byte_binary_map = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 43:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->byte_boolean_map.clear();
            uint32_t _size282;
            ::apache::thrift::protocol::TType _ktype283;
            ::apache::thrift::protocol::TType _vtype284;
            xfer += iprot->readMapBegin(_ktype283, _vtype284, _size282);
            uint32_t _i286;
            for (_i286 = 0; _i286 < _size282; ++_i286)
            {
              int8_t _key287;
              xfer += iprot->readByte(_key287);
              bool& _val288 = this->byte_boolean_map[_key287];
              xfer += iprot->readBool(_val288);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.byte_boolean_map = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 44:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->list_byte_map.clear();
            uint32_t _size289;
            ::apache::thrift::protocol::TType _ktype290;
            ::apache::thrift::protocol::TType _vtype291;
            xfer += iprot->readMapBegin(_ktype290, _vtype291, _size289);
            uint32_t _i293;
            for (_i293 = 0; _i293 < _size289; ++_i293)
            {
              std::vector<int8_t>  _key294;
              {
                _key294.clear();
                uint32_t _size296;
                ::apache::thrift::protocol::TType _etype299;
                xfer += iprot->readListBegin(_etype299, _size296);
                _key294.resize(_size296);
                uint32_t _i300;
                for (_i300 = 0; _i300 < _size296; ++_i300)
                {
                  xfer += iprot->readByte(_key294[_i300]);
                }
                xfer += iprot->readListEnd();
              }
              int8_t& _val295 = this->list_byte_map[_key294];
              xfer += iprot->readByte(_val295);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.list_byte_map = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 45:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->set_byte_map.clear();
            uint32_t _size301;
            ::apache::thrift::protocol::TType _ktype302;
            ::apache::thrift::protocol::TType _vtype303;
            xfer += iprot->readMapBegin(_ktype302, _vtype303, _size301);
            uint32_t _i305;
            for (_i305 = 0; _i305 < _size301; ++_i305)
            {
              std::set<int8_t>  _key306;
              {
                _key306.clear();
                uint32_t _size308;
                ::apache::thrift::protocol::TType _etype311;
                xfer += iprot->readSetBegin(_etype311, _size308);
                uint32_t _i312;
                for (_i312 = 0; _i312 < _size308; ++_i312)
                {
                  int8_t _elem313;
                  xfer += iprot->readByte(_elem313);
                  _key306.insert(_elem313);
                }
                xfer += iprot->readSetEnd();
              }
              int8_t& _val307 = this->set_byte_map[_key306];
              xfer += iprot->readByte(_val307);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.set_byte_map = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 46:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->map_byte_map.clear();
            uint32_t _size314;
            ::apache::thrift::protocol::TType _ktype315;
            ::apache::thrift::protocol::TType _vtype316;
            xfer += iprot->readMapBegin(_ktype315, _vtype316, _size314);
            uint32_t _i318;
            for (_i318 = 0; _i318 < _size314; ++_i318)
            {
              std::map<int8_t, int8_t>  _key319;
              {
                _key319.clear();
                uint32_t _size321;
                ::apache::thrift::protocol::TType _ktype322;
                ::apache::thrift::protocol::TType _vtype323;
                xfer += iprot->readMapBegin(_ktype322, _vtype323, _size321);
                uint32_t _i325;
                for (_i325 = 0; _i325 < _size321; ++_i325)
                {
                  int8_t _key326;
                  xfer += iprot->readByte(_key326);
                  int8_t& _val327 = _key319[_key326];
                  xfer += iprot->readByte(_val327);
                }
                xfer += iprot->readMapEnd();
              }
              int8_t& _val320 = this->map_byte_map[_key319];
              xfer += iprot->readByte(_val320);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.map_byte_map = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 47:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->byte_map_map.clear();
            uint32_t _size328;
            ::apache::thrift::protocol::TType _ktype329;
            ::apache::thrift::protocol::TType _vtype330;
            xfer += iprot->readMapBegin(_ktype329, _vtype330, _size328);
            uint32_t _i332;
            for (_i332 = 0; _i332 < _size328; ++_i332)
            {
              int8_t _key333;
              xfer += iprot->readByte(_key333);
              std::map<int8_t, int8_t> & _val334 = this->byte_map_map[_key333];
              {
                _val334.clear();
                uint32_t _size335;
                ::apache::thrift::protocol::TType _ktype336;
                ::apache::thrift::protocol::TType _vtype337;
                xfer += iprot->readMapBegin(_ktype336, _vtype337, _size335);
                uint32_t _i339;
                for (_i339 = 0; _i339 < _size335; ++_i339)
                {
                  int8_t _key340;
                  xfer += iprot->readByte(_key340);
                  int8_t& _val341 = _val334[_key340];
                  xfer += iprot->readByte(_val341);
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.byte_map_map = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 48:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->byte_set_map.clear();
            uint32_t _size342;
            ::apache::thrift::protocol::TType _ktype343;
            ::apache::thrift::protocol::TType _vtype344;
            xfer += iprot->readMapBegin(_ktype343, _vtype344, _size342);
            uint32_t _i346;
            for (_i346 = 0; _i346 < _size342; ++_i346)
            {
              int8_t _key347;
              xfer += iprot->readByte(_key347);
              std::set<int8_t> & _val348 = this->byte_set_map[_key347];
              {
                _val348.clear();
                uint32_t _size349;
                ::apache::thrift::protocol::TType _etype352;
                xfer += iprot->readSetBegin(_etype352, _size349);
                uint32_t _i353;
                for (_i353 = 0; _i353 < _size349; ++_i353)
                {
                  int8_t _elem354;
                  xfer += iprot->readByte(_elem354);
                  _val348.insert(_elem354);
                }
                xfer += iprot->readSetEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.byte_set_map = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 49:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->byte_list_map.clear();
            uint32_t _size355;
            ::apache::thrift::protocol::TType _ktype356;
            ::apache::thrift::protocol::TType _vtype357;
            xfer += iprot->readMapBegin(_ktype356, _vtype357, _size355);
            uint32_t _i359;
            for (_i359 = 0; _i359 < _size355; ++_i359)
            {
              int8_t _key360;
              xfer += iprot->readByte(_key360);
              std::vector<int8_t> & _val361 = this->byte_list_map[_key360];
              {
                _val361.clear();
                uint32_t _size362;
                ::apache::thrift::protocol::TType _etype365;
                xfer += iprot->readListBegin(_etype365, _size362);
                _val361.resize(_size362);
                uint32_t _i366;
                for (_i366 = 0; _i366 < _size362; ++_i366)
                {
                  xfer += iprot->readByte(_val361[_i366]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.byte_list_map = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CompactProtoTestStruct::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CompactProtoTestStruct");

  xfer += oprot->writeFieldBegin("a_byte", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->a_byte);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("a_i16", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->a_i16);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("a_i32", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->a_i32);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("a_i64", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->a_i64);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("a_double", ::apache::thrift::protocol::T_DOUBLE, 5);
  xfer += oprot->writeDouble(this->a_double);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("a_string", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->a_string);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("a_binary", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeBinary(this->a_binary);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("true_field", ::apache::thrift::protocol::T_BOOL, 8);
  xfer += oprot->writeBool(this->true_field);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("false_field", ::apache::thrift::protocol::T_BOOL, 9);
  xfer += oprot->writeBool(this->false_field);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("empty_struct_field", ::apache::thrift::protocol::T_STRUCT, 10);
  xfer += this->empty_struct_field.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("byte_list", ::apache::thrift::protocol::T_LIST, 11);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BYTE, static_cast<uint32_t>(this->byte_list.size()));
    std::vector<int8_t> ::const_iterator _iter367;
    for (_iter367 = this->byte_list.begin(); _iter367 != this->byte_list.end(); ++_iter367)
    {
      xfer += oprot->writeByte((*_iter367));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("i16_list", ::apache::thrift::protocol::T_LIST, 12);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>(this->i16_list.size()));
    std::vector<int16_t> ::const_iterator _iter368;
    for (_iter368 = this->i16_list.begin(); _iter368 != this->i16_list.end(); ++_iter368)
    {
      xfer += oprot->writeI16((*_iter368));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("i32_list", ::apache::thrift::protocol::T_LIST, 13);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->i32_list.size()));
    std::vector<int32_t> ::const_iterator _iter369;
    for (_iter369 = this->i32_list.begin(); _iter369 != this->i32_list.end(); ++_iter369)
    {
      xfer += oprot->writeI32((*_iter369));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("i64_list", ::apache::thrift::protocol::T_LIST, 14);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->i64_list.size()));
    std::vector<int64_t> ::const_iterator _iter370;
    for (_iter370 = this->i64_list.begin(); _iter370 != this->i64_list.end(); ++_iter370)
    {
      xfer += oprot->writeI64((*_iter370));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("double_list", ::apache::thrift::protocol::T_LIST, 15);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->double_list.size()));
    std::vector<double> ::const_iterator _iter371;
    for (_iter371 = this->double_list.begin(); _iter371 != this->double_list.end(); ++_iter371)
    {
      xfer += oprot->writeDouble((*_iter371));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("string_list", ::apache::thrift::protocol::T_LIST, 16);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->string_list.size()));
    std::vector<std::string> ::const_iterator _iter372;
    for (_iter372 = this->string_list.begin(); _iter372 != this->string_list.end(); ++_iter372)
    {
      xfer += oprot->writeString((*_iter372));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("binary_list", ::apache::thrift::protocol::T_LIST, 17);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->binary_list.size()));
    std::vector<std::string> ::const_iterator _iter373;
    for (_iter373 = this->binary_list.begin(); _iter373 != this->binary_list.end(); ++_iter373)
    {
      xfer += oprot->writeBinary((*_iter373));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("boolean_list", ::apache::thrift::protocol::T_LIST, 18);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->boolean_list.size()));
    std::vector<bool> ::const_iterator _iter374;
    for (_iter374 = this->boolean_list.begin(); _iter374 != this->boolean_list.end(); ++_iter374)
    {
      xfer += oprot->writeBool((*_iter374));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("struct_list", ::apache::thrift::protocol::T_LIST, 19);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->struct_list.size()));
    std::vector<Empty> ::const_iterator _iter375;
    for (_iter375 = this->struct_list.begin(); _iter375 != this->struct_list.end(); ++_iter375)
    {
      xfer += (*_iter375).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("byte_set", ::apache::thrift::protocol::T_SET, 20);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_BYTE, static_cast<uint32_t>(this->byte_set.size()));
    std::set<int8_t> ::const_iterator _iter376;
    for (_iter376 = this->byte_set.begin(); _iter376 != this->byte_set.end(); ++_iter376)
    {
      xfer += oprot->writeByte((*_iter376));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("i16_set", ::apache::thrift::protocol::T_SET, 21);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>(this->i16_set.size()));
    std::set<int16_t> ::const_iterator _iter377;
    for (_iter377 = this->i16_set.begin(); _iter377 != this->i16_set.end(); ++_iter377)
    {
      xfer += oprot->writeI16((*_iter377));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("i32_set", ::apache::thrift::protocol::T_SET, 22);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->i32_set.size()));
    std::set<int32_t> ::const_iterator _iter378;
    for (_iter378 = this->i32_set.begin(); _iter378 != this->i32_set.end(); ++_iter378)
    {
      xfer += oprot->writeI32((*_iter378));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("i64_set", ::apache::thrift::protocol::T_SET, 23);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->i64_set.size()));
    std::set<int64_t> ::const_iterator _iter379;
    for (_iter379 = this->i64_set.begin(); _iter379 != this->i64_set.end(); ++_iter379)
    {
      xfer += oprot->writeI64((*_iter379));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("double_set", ::apache::thrift::protocol::T_SET, 24);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->double_set.size()));
    std::set<double> ::const_iterator _iter380;
    for (_iter380 = this->double_set.begin(); _iter380 != this->double_set.end(); ++_iter380)
    {
      xfer += oprot->writeDouble((*_iter380));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("string_set", ::apache::thrift::protocol::T_SET, 25);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->string_set.size()));
    std::set<std::string> ::const_iterator _iter381;
    for (_iter381 = this->string_set.begin(); _iter381 != this->string_set.end(); ++_iter381)
    {
      xfer += oprot->writeString((*_iter381));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("binary_set", ::apache::thrift::protocol::T_SET, 26);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->binary_set.size()));
    std::set<std::string> ::const_iterator _iter382;
    for (_iter382 = this->binary_set.begin(); _iter382 != this->binary_set.end(); ++_iter382)
    {
      xfer += oprot->writeBinary((*_iter382));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("boolean_set", ::apache::thrift::protocol::T_SET, 27);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->boolean_set.size()));
    std::set<bool> ::const_iterator _iter383;
    for (_iter383 = this->boolean_set.begin(); _iter383 != this->boolean_set.end(); ++_iter383)
    {
      xfer += oprot->writeBool((*_iter383));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("struct_set", ::apache::thrift::protocol::T_SET, 28);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->struct_set.size()));
    std::set<Empty> ::const_iterator _iter384;
    for (_iter384 = this->struct_set.begin(); _iter384 != this->struct_set.end(); ++_iter384)
    {
      xfer += (*_iter384).write(oprot);
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("byte_byte_map", ::apache::thrift::protocol::T_MAP, 29);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_BYTE, ::apache::thrift::protocol::T_BYTE, static_cast<uint32_t>(this->byte_byte_map.size()));
    std::map<int8_t, int8_t> ::const_iterator _iter385;
    for (_iter385 = this->byte_byte_map.begin(); _iter385 != this->byte_byte_map.end(); ++_iter385)
    {
      xfer += oprot->writeByte(_iter385->first);
      xfer += oprot->writeByte(_iter385->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("i16_byte_map", ::apache::thrift::protocol::T_MAP, 30);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I16, ::apache::thrift::protocol::T_BYTE, static_cast<uint32_t>(this->i16_byte_map.size()));
    std::map<int16_t, int8_t> ::const_iterator _iter386;
    for (_iter386 = this->i16_byte_map.begin(); _iter386 != this->i16_byte_map.end(); ++_iter386)
    {
      xfer += oprot->writeI16(_iter386->first);
      xfer += oprot->writeByte(_iter386->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("i32_byte_map", ::apache::thrift::protocol::T_MAP, 31);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_BYTE, static_cast<uint32_t>(this->i32_byte_map.size()));
    std::map<int32_t, int8_t> ::const_iterator _iter387;
    for (_iter387 = this->i32_byte_map.begin(); _iter387 != this->i32_byte_map.end(); ++_iter387)
    {
      xfer += oprot->writeI32(_iter387->first);
      xfer += oprot->writeByte(_iter387->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("i64_byte_map", ::apache::thrift::protocol::T_MAP, 32);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I64, ::apache::thrift::protocol::T_BYTE, static_cast<uint32_t>(this->i64_byte_map.size()));
    std::map<int64_t, int8_t> ::const_iterator _iter388;
    for (_iter388 = this->i64_byte_map.begin(); _iter388 != this->i64_byte_map.end(); ++_iter388)
    {
      xfer += oprot->writeI64(_iter388->first);
      xfer += oprot->writeByte(_iter388->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("double_byte_map", ::apache::thrift::protocol::T_MAP, 33);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_DOUBLE, ::apache::thrift::protocol::T_BYTE, static_cast<uint32_t>(this->double_byte_map.size()));
    std::map<double, int8_t> ::const_iterator _iter389;
    for (_iter389 = this->double_byte_map.begin(); _iter389 != this->double_byte_map.end(); ++_iter389)
    {
      xfer += oprot->writeDouble(_iter389->first);
      xfer += oprot->writeByte(_iter389->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("string_byte_map", ::apache::thrift::protocol::T_MAP, 34);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_BYTE, static_cast<uint32_t>(this->string_byte_map.size()));
    std::map<std::string, int8_t> ::const_iterator _iter390;
    for (_iter390 = this->string_byte_map.begin(); _iter390 != this->string_byte_map.end(); ++_iter390)
    {
      xfer += oprot->writeString(_iter390->first);
      xfer += oprot->writeByte(_iter390->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("binary_byte_map", ::apache::thrift::protocol::T_MAP, 35);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_BYTE, static_cast<uint32_t>(this->binary_byte_map.size()));
    std::map<std::string, int8_t> ::const_iterator _iter391;
    for (_iter391 = this->binary_byte_map.begin(); _iter391 != this->binary_byte_map.end(); ++_iter391)
    {
      xfer += oprot->writeBinary(_iter391->first);
      xfer += oprot->writeByte(_iter391->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("boolean_byte_map", ::apache::thrift::protocol::T_MAP, 36);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_BOOL, ::apache::thrift::protocol::T_BYTE, static_cast<uint32_t>(this->boolean_byte_map.size()));
    std::map<bool, int8_t> ::const_iterator _iter392;
    for (_iter392 = this->boolean_byte_map.begin(); _iter392 != this->boolean_byte_map.end(); ++_iter392)
    {
      xfer += oprot->writeBool(_iter392->first);
      xfer += oprot->writeByte(_iter392->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("byte_i16_map", ::apache::thrift::protocol::T_MAP, 37);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_BYTE, ::apache::thrift::protocol::T_I16, static_cast<uint32_t>(this->byte_i16_map.size()));
    std::map<int8_t, int16_t> ::const_iterator _iter393;
    for (_iter393 = this->byte_i16_map.begin(); _iter393 != this->byte_i16_map.end(); ++_iter393)
    {
      xfer += oprot->writeByte(_iter393->first);
      xfer += oprot->writeI16(_iter393->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("byte_i32_map", ::apache::thrift::protocol::T_MAP, 38);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_BYTE, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->byte_i32_map.size()));
    std::map<int8_t, int32_t> ::const_iterator _iter394;
    for (_iter394 = this->byte_i32_map.begin(); _iter394 != this->byte_i32_map.end(); ++_iter394)
    {
      xfer += oprot->writeByte(_iter394->first);
      xfer += oprot->writeI32(_iter394->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("byte_i64_map", ::apache::thrift::protocol::T_MAP, 39);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_BYTE, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->byte_i64_map.size()));
    std::map<int8_t, int64_t> ::const_iterator _iter395;
    for (_iter395 = this->byte_i64_map.begin(); _iter395 != this->byte_i64_map.end(); ++_iter395)
    {
      xfer += oprot->writeByte(_iter395->first);
      xfer += oprot->writeI64(_iter395->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("byte_double_map", ::apache::thrift::protocol::T_MAP, 40);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_BYTE, ::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->byte_double_map.size()));
    std::map<int8_t, double> ::const_iterator _iter396;
    for (_iter396 = this->byte_double_map.begin(); _iter396 != this->byte_double_map.end(); ++_iter396)
    {
      xfer += oprot->writeByte(_iter396->first);
      xfer += oprot->writeDouble(_iter396->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("byte_string_map", ::apache::thrift::protocol::T_MAP, 41);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_BYTE, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->byte_string_map.size()));
    std::map<int8_t, std::string> ::const_iterator _iter397;
    for (_iter397 = this->byte_string_map.begin(); _iter397 != this->byte_string_map.end(); ++_iter397)
    {
      xfer += oprot->writeByte(_iter397->first);
      xfer += oprot->writeString(_iter397->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("byte_binary_map", ::apache::thrift::protocol::T_MAP, 42);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_BYTE, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->byte_binary_map.size()));
    std::map<int8_t, std::string> ::const_iterator _iter398;
    for (_iter398 = this->byte_binary_map.begin(); _iter398 != this->byte_binary_map.end(); ++_iter398)
    {
      xfer += oprot->writeByte(_iter398->first);
      xfer += oprot->writeBinary(_iter398->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("byte_boolean_map", ::apache::thrift::protocol::T_MAP, 43);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_BYTE, ::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->byte_boolean_map.size()));
    std::map<int8_t, bool> ::const_iterator _iter399;
    for (_iter399 = this->byte_boolean_map.begin(); _iter399 != this->byte_boolean_map.end(); ++_iter399)
    {
      xfer += oprot->writeByte(_iter399->first);
      xfer += oprot->writeBool(_iter399->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("list_byte_map", ::apache::thrift::protocol::T_MAP, 44);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_LIST, ::apache::thrift::protocol::T_BYTE, static_cast<uint32_t>(this->list_byte_map.size()));
    std::map<std::vector<int8_t> , int8_t> ::const_iterator _iter400;
    for (_iter400 = this->list_byte_map.begin(); _iter400 != this->list_byte_map.end(); ++_iter400)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BYTE, static_cast<uint32_t>(_iter400->first.size()));
        std::vector<int8_t> ::const_iterator _iter401;
        for (_iter401 = _iter400->first.begin(); _iter401 != _iter400->first.end(); ++_iter401)
        {
          xfer += oprot->writeByte((*_iter401));
        }
        xfer += oprot->writeListEnd();
      }
      xfer += oprot->writeByte(_iter400->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("set_byte_map", ::apache::thrift::protocol::T_MAP, 45);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_SET, ::apache::thrift::protocol::T_BYTE, static_cast<uint32_t>(this->set_byte_map.size()));
    std::map<std::set<int8_t> , int8_t> ::const_iterator _iter402;
    for (_iter402 = this->set_byte_map.begin(); _iter402 != this->set_byte_map.end(); ++_iter402)
    {
      {
        xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_BYTE, static_cast<uint32_t>(_iter402->first.size()));
        std::set<int8_t> ::const_iterator _iter403;
        for (_iter403 = _iter402->first.begin(); _iter403 != _iter402->first.end(); ++_iter403)
        {
          xfer += oprot->writeByte((*_iter403));
        }
        xfer += oprot->writeSetEnd();
      }
      xfer += oprot->writeByte(_iter402->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("map_byte_map", ::apache::thrift::protocol::T_MAP, 46);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_MAP, ::apache::thrift::protocol::T_BYTE, static_cast<uint32_t>(this->map_byte_map.size()));
    std::map<std::map<int8_t, int8_t> , int8_t> ::const_iterator _iter404;
    for (_iter404 = this->map_byte_map.begin(); _iter404 != this->map_byte_map.end(); ++_iter404)
    {
      {
        xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_BYTE, ::apache::thrift::protocol::T_BYTE, static_cast<uint32_t>(_iter404->first.size()));
        std::map<int8_t, int8_t> ::const_iterator _iter405;
        for (_iter405 = _iter404->first.begin(); _iter405 != _iter404->first.end(); ++_iter405)
        {
          xfer += oprot->writeByte(_iter405->first);
          xfer += oprot->writeByte(_iter405->second);
        }
        xfer += oprot->writeMapEnd();
      }
      xfer += oprot->writeByte(_iter404->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("byte_map_map", ::apache::thrift::protocol::T_MAP, 47);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_BYTE, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->byte_map_map.size()));
    std::map<int8_t, std::map<int8_t, int8_t> > ::const_iterator _iter406;
    for (_iter406 = this->byte_map_map.begin(); _iter406 != this->byte_map_map.end(); ++_iter406)
    {
      xfer += oprot->writeByte(_iter406->first);
      {
        xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_BYTE, ::apache::thrift::protocol::T_BYTE, static_cast<uint32_t>(_iter406->second.size()));
        std::map<int8_t, int8_t> ::const_iterator _iter407;
        for (_iter407 = _iter406->second.begin(); _iter407 != _iter406->second.end(); ++_iter407)
        {
          xfer += oprot->writeByte(_iter407->first);
          xfer += oprot->writeByte(_iter407->second);
        }
        xfer += oprot->writeMapEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("byte_set_map", ::apache::thrift::protocol::T_MAP, 48);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_BYTE, ::apache::thrift::protocol::T_SET, static_cast<uint32_t>(this->byte_set_map.size()));
    std::map<int8_t, std::set<int8_t> > ::const_iterator _iter408;
    for (_iter408 = this->byte_set_map.begin(); _iter408 != this->byte_set_map.end(); ++_iter408)
    {
      xfer += oprot->writeByte(_iter408->first);
      {
        xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_BYTE, static_cast<uint32_t>(_iter408->second.size()));
        std::set<int8_t> ::const_iterator _iter409;
        for (_iter409 = _iter408->second.begin(); _iter409 != _iter408->second.end(); ++_iter409)
        {
          xfer += oprot->writeByte((*_iter409));
        }
        xfer += oprot->writeSetEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("byte_list_map", ::apache::thrift::protocol::T_MAP, 49);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_BYTE, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->byte_list_map.size()));
    std::map<int8_t, std::vector<int8_t> > ::const_iterator _iter410;
    for (_iter410 = this->byte_list_map.begin(); _iter410 != this->byte_list_map.end(); ++_iter410)
    {
      xfer += oprot->writeByte(_iter410->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BYTE, static_cast<uint32_t>(_iter410->second.size()));
        std::vector<int8_t> ::const_iterator _iter411;
        for (_iter411 = _iter410->second.begin(); _iter411 != _iter410->second.end(); ++_iter411)
        {
          xfer += oprot->writeByte((*_iter411));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CompactProtoTestStruct &a, CompactProtoTestStruct &b) {
  using ::std::swap;
  swap(a.a_byte, b.a_byte);
  swap(a.a_i16, b.a_i16);
  swap(a.a_i32, b.a_i32);
  swap(a.a_i64, b.a_i64);
  swap(a.a_double, b.a_double);
  swap(a.a_string, b.a_string);
  swap(a.a_binary, b.a_binary);
  swap(a.true_field, b.true_field);
  swap(a.false_field, b.false_field);
  swap(a.empty_struct_field, b.empty_struct_field);
  swap(a.byte_list, b.byte_list);
  swap(a.i16_list, b.i16_list);
  swap(a.i32_list, b.i32_list);
  swap(a.i64_list, b.i64_list);
  swap(a.double_list, b.double_list);
  swap(a.string_list, b.string_list);
  swap(a.binary_list, b.binary_list);
  swap(a.boolean_list, b.boolean_list);
  swap(a.struct_list, b.struct_list);
  swap(a.byte_set, b.byte_set);
  swap(a.i16_set, b.i16_set);
  swap(a.i32_set, b.i32_set);
  swap(a.i64_set, b.i64_set);
  swap(a.double_set, b.double_set);
  swap(a.string_set, b.string_set);
  swap(a.binary_set, b.binary_set);
  swap(a.boolean_set, b.boolean_set);
  swap(a.struct_set, b.struct_set);
  swap(a.byte_byte_map, b.byte_byte_map);
  swap(a.i16_byte_map, b.i16_byte_map);
  swap(a.i32_byte_map, b.i32_byte_map);
  swap(a.i64_byte_map, b.i64_byte_map);
  swap(a.double_byte_map, b.double_byte_map);
  swap(a.string_byte_map, b.string_byte_map);
  swap(a.binary_byte_map, b.binary_byte_map);
  swap(a.boolean_byte_map, b.boolean_byte_map);
  swap(a.byte_i16_map, b.byte_i16_map);
  swap(a.byte_i32_map, b.byte_i32_map);
  swap(a.byte_i64_map, b.byte_i64_map);
  swap(a.byte_double_map, b.byte_double_map);
  swap(a.byte_string_map, b.byte_string_map);
  swap(a.byte_binary_map, b.byte_binary_map);
  swap(a.byte_boolean_map, b.byte_boolean_map);
  swap(a.list_byte_map, b.list_byte_map);
  swap(a.set_byte_map, b.set_byte_map);
  swap(a.map_byte_map, b.map_byte_map);
  swap(a.byte_map_map, b.byte_map_map);
  swap(a.byte_set_map, b.byte_set_map);
  swap(a.byte_list_map, b.byte_list_map);
  swap(a.__isset, b.__isset);
}

CompactProtoTestStruct::CompactProtoTestStruct(const CompactProtoTestStruct& other412) {
  a_byte = other412.a_byte;
  a_i16 = other412.a_i16;
  a_i32 = other412.a_i32;
  a_i64 = other412.a_i64;
  a_double = other412.a_double;
  a_string = other412.a_string;
  a_binary = other412.a_binary;
  true_field = other412.true_field;
  false_field = other412.false_field;
  empty_struct_field = other412.empty_struct_field;
  byte_list = other412.byte_list;
  i16_list = other412.i16_list;
  i32_list = other412.i32_list;
  i64_list = other412.i64_list;
  double_list = other412.double_list;
  string_list = other412.string_list;
  binary_list = other412.binary_list;
  boolean_list = other412.boolean_list;
  struct_list = other412.struct_list;
  byte_set = other412.byte_set;
  i16_set = other412.i16_set;
  i32_set = other412.i32_set;
  i64_set = other412.i64_set;
  double_set = other412.double_set;
  string_set = other412.string_set;
  binary_set = other412.binary_set;
  boolean_set = other412.boolean_set;
  struct_set = other412.struct_set;
  byte_byte_map = other412.byte_byte_map;
  i16_byte_map = other412.i16_byte_map;
  i32_byte_map = other412.i32_byte_map;
  i64_byte_map = other412.i64_byte_map;
  double_byte_map = other412.double_byte_map;
  string_byte_map = other412.string_byte_map;
  binary_byte_map = other412.binary_byte_map;
  boolean_byte_map = other412.boolean_byte_map;
  byte_i16_map = other412.byte_i16_map;
  byte_i32_map = other412.byte_i32_map;
  byte_i64_map = other412.byte_i64_map;
  byte_double_map = other412.byte_double_map;
  byte_string_map = other412.byte_string_map;
  byte_binary_map = other412.byte_binary_map;
  byte_boolean_map = other412.byte_boolean_map;
  list_byte_map = other412.list_byte_map;
  set_byte_map = other412.set_byte_map;
  map_byte_map = other412.map_byte_map;
  byte_map_map = other412.byte_map_map;
  byte_set_map = other412.byte_set_map;
  byte_list_map = other412.byte_list_map;
  __isset = other412.__isset;
}
CompactProtoTestStruct& CompactProtoTestStruct::operator=(const CompactProtoTestStruct& other413) {
  a_byte = other413.a_byte;
  a_i16 = other413.a_i16;
  a_i32 = other413.a_i32;
  a_i64 = other413.a_i64;
  a_double = other413.a_double;
  a_string = other413.a_string;
  a_binary = other413.a_binary;
  true_field = other413.true_field;
  false_field = other413.false_field;
  empty_struct_field = other413.empty_struct_field;
  byte_list = other413.byte_list;
  i16_list = other413.i16_list;
  i32_list = other413.i32_list;
  i64_list = other413.i64_list;
  double_list = other413.double_list;
  string_list = other413.string_list;
  binary_list = other413.binary_list;
  boolean_list = other413.boolean_list;
  struct_list = other413.struct_list;
  byte_set = other413.byte_set;
  i16_set = other413.i16_set;
  i32_set = other413.i32_set;
  i64_set = other413.i64_set;
  double_set = other413.double_set;
  string_set = other413.string_set;
  binary_set = other413.binary_set;
  boolean_set = other413.boolean_set;
  struct_set = other413.struct_set;
  byte_byte_map = other413.byte_byte_map;
  i16_byte_map = other413.i16_byte_map;
  i32_byte_map = other413.i32_byte_map;
  i64_byte_map = other413.i64_byte_map;
  double_byte_map = other413.double_byte_map;
  string_byte_map = other413.string_byte_map;
  binary_byte_map = other413.binary_byte_map;
  boolean_byte_map = other413.boolean_byte_map;
  byte_i16_map = other413.byte_i16_map;
  byte_i32_map = other413.byte_i32_map;
  byte_i64_map = other413.byte_i64_map;
  byte_double_map = other413.byte_double_map;
  byte_string_map = other413.byte_string_map;
  byte_binary_map = other413.byte_binary_map;
  byte_boolean_map = other413.byte_boolean_map;
  list_byte_map = other413.list_byte_map;
  set_byte_map = other413.set_byte_map;
  map_byte_map = other413.map_byte_map;
  byte_map_map = other413.byte_map_map;
  byte_set_map = other413.byte_set_map;
  byte_list_map = other413.byte_list_map;
  __isset = other413.__isset;
  return *this;
}
void CompactProtoTestStruct::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CompactProtoTestStruct(";
  out << "a_byte=" << to_string(a_byte);
  out << ", " << "a_i16=" << to_string(a_i16);
  out << ", " << "a_i32=" << to_string(a_i32);
  out << ", " << "a_i64=" << to_string(a_i64);
  out << ", " << "a_double=" << to_string(a_double);
  out << ", " << "a_string=" << to_string(a_string);
  out << ", " << "a_binary=" << to_string(a_binary);
  out << ", " << "true_field=" << to_string(true_field);
  out << ", " << "false_field=" << to_string(false_field);
  out << ", " << "empty_struct_field=" << to_string(empty_struct_field);
  out << ", " << "byte_list=" << to_string(byte_list);
  out << ", " << "i16_list=" << to_string(i16_list);
  out << ", " << "i32_list=" << to_string(i32_list);
  out << ", " << "i64_list=" << to_string(i64_list);
  out << ", " << "double_list=" << to_string(double_list);
  out << ", " << "string_list=" << to_string(string_list);
  out << ", " << "binary_list=" << to_string(binary_list);
  out << ", " << "boolean_list=" << to_string(boolean_list);
  out << ", " << "struct_list=" << to_string(struct_list);
  out << ", " << "byte_set=" << to_string(byte_set);
  out << ", " << "i16_set=" << to_string(i16_set);
  out << ", " << "i32_set=" << to_string(i32_set);
  out << ", " << "i64_set=" << to_string(i64_set);
  out << ", " << "double_set=" << to_string(double_set);
  out << ", " << "string_set=" << to_string(string_set);
  out << ", " << "binary_set=" << to_string(binary_set);
  out << ", " << "boolean_set=" << to_string(boolean_set);
  out << ", " << "struct_set=" << to_string(struct_set);
  out << ", " << "byte_byte_map=" << to_string(byte_byte_map);
  out << ", " << "i16_byte_map=" << to_string(i16_byte_map);
  out << ", " << "i32_byte_map=" << to_string(i32_byte_map);
  out << ", " << "i64_byte_map=" << to_string(i64_byte_map);
  out << ", " << "double_byte_map=" << to_string(double_byte_map);
  out << ", " << "string_byte_map=" << to_string(string_byte_map);
  out << ", " << "binary_byte_map=" << to_string(binary_byte_map);
  out << ", " << "boolean_byte_map=" << to_string(boolean_byte_map);
  out << ", " << "byte_i16_map=" << to_string(byte_i16_map);
  out << ", " << "byte_i32_map=" << to_string(byte_i32_map);
  out << ", " << "byte_i64_map=" << to_string(byte_i64_map);
  out << ", " << "byte_double_map=" << to_string(byte_double_map);
  out << ", " << "byte_string_map=" << to_string(byte_string_map);
  out << ", " << "byte_binary_map=" << to_string(byte_binary_map);
  out << ", " << "byte_boolean_map=" << to_string(byte_boolean_map);
  out << ", " << "list_byte_map=" << to_string(list_byte_map);
  out << ", " << "set_byte_map=" << to_string(set_byte_map);
  out << ", " << "map_byte_map=" << to_string(map_byte_map);
  out << ", " << "byte_map_map=" << to_string(byte_map_map);
  out << ", " << "byte_set_map=" << to_string(byte_set_map);
  out << ", " << "byte_list_map=" << to_string(byte_list_map);
  out << ")";
}


SingleMapTestStruct::~SingleMapTestStruct() throw() {
}


void SingleMapTestStruct::__set_i32_map(const std::map<int32_t, int32_t> & val) {
  this->i32_map = val;
}
std::ostream& operator<<(std::ostream& out, const SingleMapTestStruct& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SingleMapTestStruct::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_i32_map = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->i32_map.clear();
            uint32_t _size414;
            ::apache::thrift::protocol::TType _ktype415;
            ::apache::thrift::protocol::TType _vtype416;
            xfer += iprot->readMapBegin(_ktype415, _vtype416, _size414);
            uint32_t _i418;
            for (_i418 = 0; _i418 < _size414; ++_i418)
            {
              int32_t _key419;
              xfer += iprot->readI32(_key419);
              int32_t& _val420 = this->i32_map[_key419];
              xfer += iprot->readI32(_val420);
            }
            xfer += iprot->readMapEnd();
          }
          isset_i32_map = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_i32_map)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t SingleMapTestStruct::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SingleMapTestStruct");

  xfer += oprot->writeFieldBegin("i32_map", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->i32_map.size()));
    std::map<int32_t, int32_t> ::const_iterator _iter421;
    for (_iter421 = this->i32_map.begin(); _iter421 != this->i32_map.end(); ++_iter421)
    {
      xfer += oprot->writeI32(_iter421->first);
      xfer += oprot->writeI32(_iter421->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SingleMapTestStruct &a, SingleMapTestStruct &b) {
  using ::std::swap;
  swap(a.i32_map, b.i32_map);
}

SingleMapTestStruct::SingleMapTestStruct(const SingleMapTestStruct& other422) {
  i32_map = other422.i32_map;
}
SingleMapTestStruct& SingleMapTestStruct::operator=(const SingleMapTestStruct& other423) {
  i32_map = other423.i32_map;
  return *this;
}
void SingleMapTestStruct::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SingleMapTestStruct(";
  out << "i32_map=" << to_string(i32_map);
  out << ")";
}


ExceptionWithAMap::~ExceptionWithAMap() throw() {
}


void ExceptionWithAMap::__set_blah(const std::string& val) {
  this->blah = val;
}

void ExceptionWithAMap::__set_map_field(const std::map<std::string, std::string> & val) {
  this->map_field = val;
}
std::ostream& operator<<(std::ostream& out, const ExceptionWithAMap& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ExceptionWithAMap::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->blah);
          this->__isset.blah = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->map_field.clear();
            uint32_t _size424;
            ::apache::thrift::protocol::TType _ktype425;
            ::apache::thrift::protocol::TType _vtype426;
            xfer += iprot->readMapBegin(_ktype425, _vtype426, _size424);
            uint32_t _i428;
            for (_i428 = 0; _i428 < _size424; ++_i428)
            {
              std::string _key429;
              xfer += iprot->readString(_key429);
              std::string& _val430 = this->map_field[_key429];
              xfer += iprot->readString(_val430);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.map_field = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ExceptionWithAMap::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ExceptionWithAMap");

  xfer += oprot->writeFieldBegin("blah", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->blah);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("map_field", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->map_field.size()));
    std::map<std::string, std::string> ::const_iterator _iter431;
    for (_iter431 = this->map_field.begin(); _iter431 != this->map_field.end(); ++_iter431)
    {
      xfer += oprot->writeString(_iter431->first);
      xfer += oprot->writeString(_iter431->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ExceptionWithAMap &a, ExceptionWithAMap &b) {
  using ::std::swap;
  swap(a.blah, b.blah);
  swap(a.map_field, b.map_field);
  swap(a.__isset, b.__isset);
}

ExceptionWithAMap::ExceptionWithAMap(const ExceptionWithAMap& other432) : TException() {
  blah = other432.blah;
  map_field = other432.map_field;
  __isset = other432.__isset;
}
ExceptionWithAMap& ExceptionWithAMap::operator=(const ExceptionWithAMap& other433) {
  blah = other433.blah;
  map_field = other433.map_field;
  __isset = other433.__isset;
  return *this;
}
void ExceptionWithAMap::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ExceptionWithAMap(";
  out << "blah=" << to_string(blah);
  out << ", " << "map_field=" << to_string(map_field);
  out << ")";
}

const char* ExceptionWithAMap::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: ExceptionWithAMap";
  }
}


BlowUp::~BlowUp() throw() {
}


void BlowUp::__set_b1(const std::map<std::vector<int32_t> , std::set<std::map<int32_t, std::string> > > & val) {
  this->b1 = val;
}

void BlowUp::__set_b2(const std::map<std::vector<int32_t> , std::set<std::map<int32_t, std::string> > > & val) {
  this->b2 = val;
}

void BlowUp::__set_b3(const std::map<std::vector<int32_t> , std::set<std::map<int32_t, std::string> > > & val) {
  this->b3 = val;
}

void BlowUp::__set_b4(const std::map<std::vector<int32_t> , std::set<std::map<int32_t, std::string> > > & val) {
  this->b4 = val;
}
std::ostream& operator<<(std::ostream& out, const BlowUp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t BlowUp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->b1.clear();
            uint32_t _size434;
            ::apache::thrift::protocol::TType _ktype435;
            ::apache::thrift::protocol::TType _vtype436;
            xfer += iprot->readMapBegin(_ktype435, _vtype436, _size434);
            uint32_t _i438;
            for (_i438 = 0; _i438 < _size434; ++_i438)
            {
              std::vector<int32_t>  _key439;
              {
                _key439.clear();
                uint32_t _size441;
                ::apache::thrift::protocol::TType _etype444;
                xfer += iprot->readListBegin(_etype444, _size441);
                _key439.resize(_size441);
                uint32_t _i445;
                for (_i445 = 0; _i445 < _size441; ++_i445)
                {
                  xfer += iprot->readI32(_key439[_i445]);
                }
                xfer += iprot->readListEnd();
              }
              std::set<std::map<int32_t, std::string> > & _val440 = this->b1[_key439];
              {
                _val440.clear();
                uint32_t _size446;
                ::apache::thrift::protocol::TType _etype449;
                xfer += iprot->readSetBegin(_etype449, _size446);
                uint32_t _i450;
                for (_i450 = 0; _i450 < _size446; ++_i450)
                {
                  std::map<int32_t, std::string>  _elem451;
                  {
                    _elem451.clear();
                    uint32_t _size452;
                    ::apache::thrift::protocol::TType _ktype453;
                    ::apache::thrift::protocol::TType _vtype454;
                    xfer += iprot->readMapBegin(_ktype453, _vtype454, _size452);
                    uint32_t _i456;
                    for (_i456 = 0; _i456 < _size452; ++_i456)
                    {
                      int32_t _key457;
                      xfer += iprot->readI32(_key457);
                      std::string& _val458 = _elem451[_key457];
                      xfer += iprot->readString(_val458);
                    }
                    xfer += iprot->readMapEnd();
                  }
                  _val440.insert(_elem451);
                }
                xfer += iprot->readSetEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.b1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->b2.clear();
            uint32_t _size459;
            ::apache::thrift::protocol::TType _ktype460;
            ::apache::thrift::protocol::TType _vtype461;
            xfer += iprot->readMapBegin(_ktype460, _vtype461, _size459);
            uint32_t _i463;
            for (_i463 = 0; _i463 < _size459; ++_i463)
            {
              std::vector<int32_t>  _key464;
              {
                _key464.clear();
                uint32_t _size466;
                ::apache::thrift::protocol::TType _etype469;
                xfer += iprot->readListBegin(_etype469, _size466);
                _key464.resize(_size466);
                uint32_t _i470;
                for (_i470 = 0; _i470 < _size466; ++_i470)
                {
                  xfer += iprot->readI32(_key464[_i470]);
                }
                xfer += iprot->readListEnd();
              }
              std::set<std::map<int32_t, std::string> > & _val465 = this->b2[_key464];
              {
                _val465.clear();
                uint32_t _size471;
                ::apache::thrift::protocol::TType _etype474;
                xfer += iprot->readSetBegin(_etype474, _size471);
                uint32_t _i475;
                for (_i475 = 0; _i475 < _size471; ++_i475)
                {
                  std::map<int32_t, std::string>  _elem476;
                  {
                    _elem476.clear();
                    uint32_t _size477;
                    ::apache::thrift::protocol::TType _ktype478;
                    ::apache::thrift::protocol::TType _vtype479;
                    xfer += iprot->readMapBegin(_ktype478, _vtype479, _size477);
                    uint32_t _i481;
                    for (_i481 = 0; _i481 < _size477; ++_i481)
                    {
                      int32_t _key482;
                      xfer += iprot->readI32(_key482);
                      std::string& _val483 = _elem476[_key482];
                      xfer += iprot->readString(_val483);
                    }
                    xfer += iprot->readMapEnd();
                  }
                  _val465.insert(_elem476);
                }
                xfer += iprot->readSetEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.b2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->b3.clear();
            uint32_t _size484;
            ::apache::thrift::protocol::TType _ktype485;
            ::apache::thrift::protocol::TType _vtype486;
            xfer += iprot->readMapBegin(_ktype485, _vtype486, _size484);
            uint32_t _i488;
            for (_i488 = 0; _i488 < _size484; ++_i488)
            {
              std::vector<int32_t>  _key489;
              {
                _key489.clear();
                uint32_t _size491;
                ::apache::thrift::protocol::TType _etype494;
                xfer += iprot->readListBegin(_etype494, _size491);
                _key489.resize(_size491);
                uint32_t _i495;
                for (_i495 = 0; _i495 < _size491; ++_i495)
                {
                  xfer += iprot->readI32(_key489[_i495]);
                }
                xfer += iprot->readListEnd();
              }
              std::set<std::map<int32_t, std::string> > & _val490 = this->b3[_key489];
              {
                _val490.clear();
                uint32_t _size496;
                ::apache::thrift::protocol::TType _etype499;
                xfer += iprot->readSetBegin(_etype499, _size496);
                uint32_t _i500;
                for (_i500 = 0; _i500 < _size496; ++_i500)
                {
                  std::map<int32_t, std::string>  _elem501;
                  {
                    _elem501.clear();
                    uint32_t _size502;
                    ::apache::thrift::protocol::TType _ktype503;
                    ::apache::thrift::protocol::TType _vtype504;
                    xfer += iprot->readMapBegin(_ktype503, _vtype504, _size502);
                    uint32_t _i506;
                    for (_i506 = 0; _i506 < _size502; ++_i506)
                    {
                      int32_t _key507;
                      xfer += iprot->readI32(_key507);
                      std::string& _val508 = _elem501[_key507];
                      xfer += iprot->readString(_val508);
                    }
                    xfer += iprot->readMapEnd();
                  }
                  _val490.insert(_elem501);
                }
                xfer += iprot->readSetEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.b3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->b4.clear();
            uint32_t _size509;
            ::apache::thrift::protocol::TType _ktype510;
            ::apache::thrift::protocol::TType _vtype511;
            xfer += iprot->readMapBegin(_ktype510, _vtype511, _size509);
            uint32_t _i513;
            for (_i513 = 0; _i513 < _size509; ++_i513)
            {
              std::vector<int32_t>  _key514;
              {
                _key514.clear();
                uint32_t _size516;
                ::apache::thrift::protocol::TType _etype519;
                xfer += iprot->readListBegin(_etype519, _size516);
                _key514.resize(_size516);
                uint32_t _i520;
                for (_i520 = 0; _i520 < _size516; ++_i520)
                {
                  xfer += iprot->readI32(_key514[_i520]);
                }
                xfer += iprot->readListEnd();
              }
              std::set<std::map<int32_t, std::string> > & _val515 = this->b4[_key514];
              {
                _val515.clear();
                uint32_t _size521;
                ::apache::thrift::protocol::TType _etype524;
                xfer += iprot->readSetBegin(_etype524, _size521);
                uint32_t _i525;
                for (_i525 = 0; _i525 < _size521; ++_i525)
                {
                  std::map<int32_t, std::string>  _elem526;
                  {
                    _elem526.clear();
                    uint32_t _size527;
                    ::apache::thrift::protocol::TType _ktype528;
                    ::apache::thrift::protocol::TType _vtype529;
                    xfer += iprot->readMapBegin(_ktype528, _vtype529, _size527);
                    uint32_t _i531;
                    for (_i531 = 0; _i531 < _size527; ++_i531)
                    {
                      int32_t _key532;
                      xfer += iprot->readI32(_key532);
                      std::string& _val533 = _elem526[_key532];
                      xfer += iprot->readString(_val533);
                    }
                    xfer += iprot->readMapEnd();
                  }
                  _val515.insert(_elem526);
                }
                xfer += iprot->readSetEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.b4 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BlowUp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BlowUp");

  xfer += oprot->writeFieldBegin("b1", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_LIST, ::apache::thrift::protocol::T_SET, static_cast<uint32_t>(this->b1.size()));
    std::map<std::vector<int32_t> , std::set<std::map<int32_t, std::string> > > ::const_iterator _iter534;
    for (_iter534 = this->b1.begin(); _iter534 != this->b1.end(); ++_iter534)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(_iter534->first.size()));
        std::vector<int32_t> ::const_iterator _iter535;
        for (_iter535 = _iter534->first.begin(); _iter535 != _iter534->first.end(); ++_iter535)
        {
          xfer += oprot->writeI32((*_iter535));
        }
        xfer += oprot->writeListEnd();
      }
      {
        xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(_iter534->second.size()));
        std::set<std::map<int32_t, std::string> > ::const_iterator _iter536;
        for (_iter536 = _iter534->second.begin(); _iter536 != _iter534->second.end(); ++_iter536)
        {
          {
            xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*_iter536).size()));
            std::map<int32_t, std::string> ::const_iterator _iter537;
            for (_iter537 = (*_iter536).begin(); _iter537 != (*_iter536).end(); ++_iter537)
            {
              xfer += oprot->writeI32(_iter537->first);
              xfer += oprot->writeString(_iter537->second);
            }
            xfer += oprot->writeMapEnd();
          }
        }
        xfer += oprot->writeSetEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("b2", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_LIST, ::apache::thrift::protocol::T_SET, static_cast<uint32_t>(this->b2.size()));
    std::map<std::vector<int32_t> , std::set<std::map<int32_t, std::string> > > ::const_iterator _iter538;
    for (_iter538 = this->b2.begin(); _iter538 != this->b2.end(); ++_iter538)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(_iter538->first.size()));
        std::vector<int32_t> ::const_iterator _iter539;
        for (_iter539 = _iter538->first.begin(); _iter539 != _iter538->first.end(); ++_iter539)
        {
          xfer += oprot->writeI32((*_iter539));
        }
        xfer += oprot->writeListEnd();
      }
      {
        xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(_iter538->second.size()));
        std::set<std::map<int32_t, std::string> > ::const_iterator _iter540;
        for (_iter540 = _iter538->second.begin(); _iter540 != _iter538->second.end(); ++_iter540)
        {
          {
            xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*_iter540).size()));
            std::map<int32_t, std::string> ::const_iterator _iter541;
            for (_iter541 = (*_iter540).begin(); _iter541 != (*_iter540).end(); ++_iter541)
            {
              xfer += oprot->writeI32(_iter541->first);
              xfer += oprot->writeString(_iter541->second);
            }
            xfer += oprot->writeMapEnd();
          }
        }
        xfer += oprot->writeSetEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("b3", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_LIST, ::apache::thrift::protocol::T_SET, static_cast<uint32_t>(this->b3.size()));
    std::map<std::vector<int32_t> , std::set<std::map<int32_t, std::string> > > ::const_iterator _iter542;
    for (_iter542 = this->b3.begin(); _iter542 != this->b3.end(); ++_iter542)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(_iter542->first.size()));
        std::vector<int32_t> ::const_iterator _iter543;
        for (_iter543 = _iter542->first.begin(); _iter543 != _iter542->first.end(); ++_iter543)
        {
          xfer += oprot->writeI32((*_iter543));
        }
        xfer += oprot->writeListEnd();
      }
      {
        xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(_iter542->second.size()));
        std::set<std::map<int32_t, std::string> > ::const_iterator _iter544;
        for (_iter544 = _iter542->second.begin(); _iter544 != _iter542->second.end(); ++_iter544)
        {
          {
            xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*_iter544).size()));
            std::map<int32_t, std::string> ::const_iterator _iter545;
            for (_iter545 = (*_iter544).begin(); _iter545 != (*_iter544).end(); ++_iter545)
            {
              xfer += oprot->writeI32(_iter545->first);
              xfer += oprot->writeString(_iter545->second);
            }
            xfer += oprot->writeMapEnd();
          }
        }
        xfer += oprot->writeSetEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("b4", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_LIST, ::apache::thrift::protocol::T_SET, static_cast<uint32_t>(this->b4.size()));
    std::map<std::vector<int32_t> , std::set<std::map<int32_t, std::string> > > ::const_iterator _iter546;
    for (_iter546 = this->b4.begin(); _iter546 != this->b4.end(); ++_iter546)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(_iter546->first.size()));
        std::vector<int32_t> ::const_iterator _iter547;
        for (_iter547 = _iter546->first.begin(); _iter547 != _iter546->first.end(); ++_iter547)
        {
          xfer += oprot->writeI32((*_iter547));
        }
        xfer += oprot->writeListEnd();
      }
      {
        xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(_iter546->second.size()));
        std::set<std::map<int32_t, std::string> > ::const_iterator _iter548;
        for (_iter548 = _iter546->second.begin(); _iter548 != _iter546->second.end(); ++_iter548)
        {
          {
            xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*_iter548).size()));
            std::map<int32_t, std::string> ::const_iterator _iter549;
            for (_iter549 = (*_iter548).begin(); _iter549 != (*_iter548).end(); ++_iter549)
            {
              xfer += oprot->writeI32(_iter549->first);
              xfer += oprot->writeString(_iter549->second);
            }
            xfer += oprot->writeMapEnd();
          }
        }
        xfer += oprot->writeSetEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BlowUp &a, BlowUp &b) {
  using ::std::swap;
  swap(a.b1, b.b1);
  swap(a.b2, b.b2);
  swap(a.b3, b.b3);
  swap(a.b4, b.b4);
  swap(a.__isset, b.__isset);
}

BlowUp::BlowUp(const BlowUp& other550) {
  b1 = other550.b1;
  b2 = other550.b2;
  b3 = other550.b3;
  b4 = other550.b4;
  __isset = other550.__isset;
}
BlowUp& BlowUp::operator=(const BlowUp& other551) {
  b1 = other551.b1;
  b2 = other551.b2;
  b3 = other551.b3;
  b4 = other551.b4;
  __isset = other551.__isset;
  return *this;
}
void BlowUp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BlowUp(";
  out << "b1=" << to_string(b1);
  out << ", " << "b2=" << to_string(b2);
  out << ", " << "b3=" << to_string(b3);
  out << ", " << "b4=" << to_string(b4);
  out << ")";
}


ReverseOrderStruct::~ReverseOrderStruct() throw() {
}


void ReverseOrderStruct::__set_first(const std::string& val) {
  this->first = val;
}

void ReverseOrderStruct::__set_second(const int16_t val) {
  this->second = val;
}

void ReverseOrderStruct::__set_third(const int32_t val) {
  this->third = val;
}

void ReverseOrderStruct::__set_fourth(const int64_t val) {
  this->fourth = val;
}
std::ostream& operator<<(std::ostream& out, const ReverseOrderStruct& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ReverseOrderStruct::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->first);
          this->__isset.first = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->second);
          this->__isset.second = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->third);
          this->__isset.third = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->fourth);
          this->__isset.fourth = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ReverseOrderStruct::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ReverseOrderStruct");

  xfer += oprot->writeFieldBegin("fourth", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->fourth);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("third", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->third);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("second", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->second);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("first", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->first);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ReverseOrderStruct &a, ReverseOrderStruct &b) {
  using ::std::swap;
  swap(a.first, b.first);
  swap(a.second, b.second);
  swap(a.third, b.third);
  swap(a.fourth, b.fourth);
  swap(a.__isset, b.__isset);
}

ReverseOrderStruct::ReverseOrderStruct(const ReverseOrderStruct& other552) {
  first = other552.first;
  second = other552.second;
  third = other552.third;
  fourth = other552.fourth;
  __isset = other552.__isset;
}
ReverseOrderStruct& ReverseOrderStruct::operator=(const ReverseOrderStruct& other553) {
  first = other553.first;
  second = other553.second;
  third = other553.third;
  fourth = other553.fourth;
  __isset = other553.__isset;
  return *this;
}
void ReverseOrderStruct::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ReverseOrderStruct(";
  out << "first=" << to_string(first);
  out << ", " << "second=" << to_string(second);
  out << ", " << "third=" << to_string(third);
  out << ", " << "fourth=" << to_string(fourth);
  out << ")";
}


StructWithSomeEnum::~StructWithSomeEnum() throw() {
}


void StructWithSomeEnum::__set_blah(const SomeEnum::type val) {
  this->blah = val;
}
std::ostream& operator<<(std::ostream& out, const StructWithSomeEnum& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t StructWithSomeEnum::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast554;
          xfer += iprot->readI32(ecast554);
          this->blah = (SomeEnum::type)ecast554;
          this->__isset.blah = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t StructWithSomeEnum::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("StructWithSomeEnum");

  xfer += oprot->writeFieldBegin("blah", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->blah);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(StructWithSomeEnum &a, StructWithSomeEnum &b) {
  using ::std::swap;
  swap(a.blah, b.blah);
  swap(a.__isset, b.__isset);
}

StructWithSomeEnum::StructWithSomeEnum(const StructWithSomeEnum& other555) {
  blah = other555.blah;
  __isset = other555.__isset;
}
StructWithSomeEnum& StructWithSomeEnum::operator=(const StructWithSomeEnum& other556) {
  blah = other556.blah;
  __isset = other556.__isset;
  return *this;
}
void StructWithSomeEnum::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "StructWithSomeEnum(";
  out << "blah=" << to_string(blah);
  out << ")";
}


TestUnion::~TestUnion() throw() {
}


void TestUnion::__set_string_field(const std::string& val) {
  this->string_field = val;
__isset.string_field = true;
}

void TestUnion::__set_i32_field(const int32_t val) {
  this->i32_field = val;
__isset.i32_field = true;
}

void TestUnion::__set_struct_field(const OneOfEach& val) {
  this->struct_field = val;
__isset.struct_field = true;
}

void TestUnion::__set_struct_list(const std::vector<RandomStuff> & val) {
  this->struct_list = val;
__isset.struct_list = true;
}

void TestUnion::__set_other_i32_field(const int32_t val) {
  this->other_i32_field = val;
__isset.other_i32_field = true;
}

void TestUnion::__set_enum_field(const SomeEnum::type val) {
  this->enum_field = val;
__isset.enum_field = true;
}

void TestUnion::__set_i32_set(const std::set<int32_t> & val) {
  this->i32_set = val;
__isset.i32_set = true;
}

void TestUnion::__set_i32_map(const std::map<int32_t, int32_t> & val) {
  this->i32_map = val;
__isset.i32_map = true;
}
std::ostream& operator<<(std::ostream& out, const TestUnion& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TestUnion::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->string_field);
          this->__isset.string_field = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->i32_field);
          this->__isset.i32_field = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->struct_field.read(iprot);
          this->__isset.struct_field = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->struct_list.clear();
            uint32_t _size557;
            ::apache::thrift::protocol::TType _etype560;
            xfer += iprot->readListBegin(_etype560, _size557);
            this->struct_list.resize(_size557);
            uint32_t _i561;
            for (_i561 = 0; _i561 < _size557; ++_i561)
            {
              xfer += this->struct_list[_i561].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.struct_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->other_i32_field);
          this->__isset.other_i32_field = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast562;
          xfer += iprot->readI32(ecast562);
          this->enum_field = (SomeEnum::type)ecast562;
          this->__isset.enum_field = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->i32_set.clear();
            uint32_t _size563;
            ::apache::thrift::protocol::TType _etype566;
            xfer += iprot->readSetBegin(_etype566, _size563);
            uint32_t _i567;
            for (_i567 = 0; _i567 < _size563; ++_i567)
            {
              int32_t _elem568;
              xfer += iprot->readI32(_elem568);
              this->i32_set.insert(_elem568);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.i32_set = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->i32_map.clear();
            uint32_t _size569;
            ::apache::thrift::protocol::TType _ktype570;
            ::apache::thrift::protocol::TType _vtype571;
            xfer += iprot->readMapBegin(_ktype570, _vtype571, _size569);
            uint32_t _i573;
            for (_i573 = 0; _i573 < _size569; ++_i573)
            {
              int32_t _key574;
              xfer += iprot->readI32(_key574);
              int32_t& _val575 = this->i32_map[_key574];
              xfer += iprot->readI32(_val575);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.i32_map = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TestUnion::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TestUnion");

  if (this->__isset.string_field) {
    xfer += oprot->writeFieldBegin("string_field", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->string_field);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.i32_field) {
    xfer += oprot->writeFieldBegin("i32_field", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->i32_field);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.struct_field) {
    xfer += oprot->writeFieldBegin("struct_field", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->struct_field.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.struct_list) {
    xfer += oprot->writeFieldBegin("struct_list", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->struct_list.size()));
      std::vector<RandomStuff> ::const_iterator _iter576;
      for (_iter576 = this->struct_list.begin(); _iter576 != this->struct_list.end(); ++_iter576)
      {
        xfer += (*_iter576).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.other_i32_field) {
    xfer += oprot->writeFieldBegin("other_i32_field", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->other_i32_field);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.enum_field) {
    xfer += oprot->writeFieldBegin("enum_field", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32((int32_t)this->enum_field);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.i32_set) {
    xfer += oprot->writeFieldBegin("i32_set", ::apache::thrift::protocol::T_SET, 7);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->i32_set.size()));
      std::set<int32_t> ::const_iterator _iter577;
      for (_iter577 = this->i32_set.begin(); _iter577 != this->i32_set.end(); ++_iter577)
      {
        xfer += oprot->writeI32((*_iter577));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.i32_map) {
    xfer += oprot->writeFieldBegin("i32_map", ::apache::thrift::protocol::T_MAP, 8);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->i32_map.size()));
      std::map<int32_t, int32_t> ::const_iterator _iter578;
      for (_iter578 = this->i32_map.begin(); _iter578 != this->i32_map.end(); ++_iter578)
      {
        xfer += oprot->writeI32(_iter578->first);
        xfer += oprot->writeI32(_iter578->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TestUnion &a, TestUnion &b) {
  using ::std::swap;
  swap(a.string_field, b.string_field);
  swap(a.i32_field, b.i32_field);
  swap(a.struct_field, b.struct_field);
  swap(a.struct_list, b.struct_list);
  swap(a.other_i32_field, b.other_i32_field);
  swap(a.enum_field, b.enum_field);
  swap(a.i32_set, b.i32_set);
  swap(a.i32_map, b.i32_map);
  swap(a.__isset, b.__isset);
}

TestUnion::TestUnion(const TestUnion& other579) {
  string_field = other579.string_field;
  i32_field = other579.i32_field;
  struct_field = other579.struct_field;
  struct_list = other579.struct_list;
  other_i32_field = other579.other_i32_field;
  enum_field = other579.enum_field;
  i32_set = other579.i32_set;
  i32_map = other579.i32_map;
  __isset = other579.__isset;
}
TestUnion& TestUnion::operator=(const TestUnion& other580) {
  string_field = other580.string_field;
  i32_field = other580.i32_field;
  struct_field = other580.struct_field;
  struct_list = other580.struct_list;
  other_i32_field = other580.other_i32_field;
  enum_field = other580.enum_field;
  i32_set = other580.i32_set;
  i32_map = other580.i32_map;
  __isset = other580.__isset;
  return *this;
}
void TestUnion::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TestUnion(";
  out << "string_field="; (__isset.string_field ? (out << to_string(string_field)) : (out << "<null>"));
  out << ", " << "i32_field="; (__isset.i32_field ? (out << to_string(i32_field)) : (out << "<null>"));
  out << ", " << "struct_field="; (__isset.struct_field ? (out << to_string(struct_field)) : (out << "<null>"));
  out << ", " << "struct_list="; (__isset.struct_list ? (out << to_string(struct_list)) : (out << "<null>"));
  out << ", " << "other_i32_field="; (__isset.other_i32_field ? (out << to_string(other_i32_field)) : (out << "<null>"));
  out << ", " << "enum_field="; (__isset.enum_field ? (out << to_string(enum_field)) : (out << "<null>"));
  out << ", " << "i32_set="; (__isset.i32_set ? (out << to_string(i32_set)) : (out << "<null>"));
  out << ", " << "i32_map="; (__isset.i32_map ? (out << to_string(i32_map)) : (out << "<null>"));
  out << ")";
}


TestUnionMinusStringField::~TestUnionMinusStringField() throw() {
}


void TestUnionMinusStringField::__set_i32_field(const int32_t val) {
  this->i32_field = val;
__isset.i32_field = true;
}

void TestUnionMinusStringField::__set_struct_field(const OneOfEach& val) {
  this->struct_field = val;
__isset.struct_field = true;
}

void TestUnionMinusStringField::__set_struct_list(const std::vector<RandomStuff> & val) {
  this->struct_list = val;
__isset.struct_list = true;
}

void TestUnionMinusStringField::__set_other_i32_field(const int32_t val) {
  this->other_i32_field = val;
__isset.other_i32_field = true;
}

void TestUnionMinusStringField::__set_enum_field(const SomeEnum::type val) {
  this->enum_field = val;
__isset.enum_field = true;
}

void TestUnionMinusStringField::__set_i32_set(const std::set<int32_t> & val) {
  this->i32_set = val;
__isset.i32_set = true;
}

void TestUnionMinusStringField::__set_i32_map(const std::map<int32_t, int32_t> & val) {
  this->i32_map = val;
__isset.i32_map = true;
}
std::ostream& operator<<(std::ostream& out, const TestUnionMinusStringField& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TestUnionMinusStringField::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->i32_field);
          this->__isset.i32_field = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->struct_field.read(iprot);
          this->__isset.struct_field = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->struct_list.clear();
            uint32_t _size581;
            ::apache::thrift::protocol::TType _etype584;
            xfer += iprot->readListBegin(_etype584, _size581);
            this->struct_list.resize(_size581);
            uint32_t _i585;
            for (_i585 = 0; _i585 < _size581; ++_i585)
            {
              xfer += this->struct_list[_i585].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.struct_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->other_i32_field);
          this->__isset.other_i32_field = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast586;
          xfer += iprot->readI32(ecast586);
          this->enum_field = (SomeEnum::type)ecast586;
          this->__isset.enum_field = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->i32_set.clear();
            uint32_t _size587;
            ::apache::thrift::protocol::TType _etype590;
            xfer += iprot->readSetBegin(_etype590, _size587);
            uint32_t _i591;
            for (_i591 = 0; _i591 < _size587; ++_i591)
            {
              int32_t _elem592;
              xfer += iprot->readI32(_elem592);
              this->i32_set.insert(_elem592);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.i32_set = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->i32_map.clear();
            uint32_t _size593;
            ::apache::thrift::protocol::TType _ktype594;
            ::apache::thrift::protocol::TType _vtype595;
            xfer += iprot->readMapBegin(_ktype594, _vtype595, _size593);
            uint32_t _i597;
            for (_i597 = 0; _i597 < _size593; ++_i597)
            {
              int32_t _key598;
              xfer += iprot->readI32(_key598);
              int32_t& _val599 = this->i32_map[_key598];
              xfer += iprot->readI32(_val599);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.i32_map = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TestUnionMinusStringField::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TestUnionMinusStringField");

  if (this->__isset.i32_field) {
    xfer += oprot->writeFieldBegin("i32_field", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->i32_field);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.struct_field) {
    xfer += oprot->writeFieldBegin("struct_field", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->struct_field.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.struct_list) {
    xfer += oprot->writeFieldBegin("struct_list", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->struct_list.size()));
      std::vector<RandomStuff> ::const_iterator _iter600;
      for (_iter600 = this->struct_list.begin(); _iter600 != this->struct_list.end(); ++_iter600)
      {
        xfer += (*_iter600).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.other_i32_field) {
    xfer += oprot->writeFieldBegin("other_i32_field", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->other_i32_field);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.enum_field) {
    xfer += oprot->writeFieldBegin("enum_field", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32((int32_t)this->enum_field);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.i32_set) {
    xfer += oprot->writeFieldBegin("i32_set", ::apache::thrift::protocol::T_SET, 7);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->i32_set.size()));
      std::set<int32_t> ::const_iterator _iter601;
      for (_iter601 = this->i32_set.begin(); _iter601 != this->i32_set.end(); ++_iter601)
      {
        xfer += oprot->writeI32((*_iter601));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.i32_map) {
    xfer += oprot->writeFieldBegin("i32_map", ::apache::thrift::protocol::T_MAP, 8);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->i32_map.size()));
      std::map<int32_t, int32_t> ::const_iterator _iter602;
      for (_iter602 = this->i32_map.begin(); _iter602 != this->i32_map.end(); ++_iter602)
      {
        xfer += oprot->writeI32(_iter602->first);
        xfer += oprot->writeI32(_iter602->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TestUnionMinusStringField &a, TestUnionMinusStringField &b) {
  using ::std::swap;
  swap(a.i32_field, b.i32_field);
  swap(a.struct_field, b.struct_field);
  swap(a.struct_list, b.struct_list);
  swap(a.other_i32_field, b.other_i32_field);
  swap(a.enum_field, b.enum_field);
  swap(a.i32_set, b.i32_set);
  swap(a.i32_map, b.i32_map);
  swap(a.__isset, b.__isset);
}

TestUnionMinusStringField::TestUnionMinusStringField(const TestUnionMinusStringField& other603) {
  i32_field = other603.i32_field;
  struct_field = other603.struct_field;
  struct_list = other603.struct_list;
  other_i32_field = other603.other_i32_field;
  enum_field = other603.enum_field;
  i32_set = other603.i32_set;
  i32_map = other603.i32_map;
  __isset = other603.__isset;
}
TestUnionMinusStringField& TestUnionMinusStringField::operator=(const TestUnionMinusStringField& other604) {
  i32_field = other604.i32_field;
  struct_field = other604.struct_field;
  struct_list = other604.struct_list;
  other_i32_field = other604.other_i32_field;
  enum_field = other604.enum_field;
  i32_set = other604.i32_set;
  i32_map = other604.i32_map;
  __isset = other604.__isset;
  return *this;
}
void TestUnionMinusStringField::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TestUnionMinusStringField(";
  out << "i32_field="; (__isset.i32_field ? (out << to_string(i32_field)) : (out << "<null>"));
  out << ", " << "struct_field="; (__isset.struct_field ? (out << to_string(struct_field)) : (out << "<null>"));
  out << ", " << "struct_list="; (__isset.struct_list ? (out << to_string(struct_list)) : (out << "<null>"));
  out << ", " << "other_i32_field="; (__isset.other_i32_field ? (out << to_string(other_i32_field)) : (out << "<null>"));
  out << ", " << "enum_field="; (__isset.enum_field ? (out << to_string(enum_field)) : (out << "<null>"));
  out << ", " << "i32_set="; (__isset.i32_set ? (out << to_string(i32_set)) : (out << "<null>"));
  out << ", " << "i32_map="; (__isset.i32_map ? (out << to_string(i32_map)) : (out << "<null>"));
  out << ")";
}


ComparableUnion::~ComparableUnion() throw() {
}


void ComparableUnion::__set_string_field(const std::string& val) {
  this->string_field = val;
__isset.string_field = true;
}

void ComparableUnion::__set_binary_field(const std::string& val) {
  this->binary_field = val;
__isset.binary_field = true;
}
std::ostream& operator<<(std::ostream& out, const ComparableUnion& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ComparableUnion::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->string_field);
          this->__isset.string_field = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->binary_field);
          this->__isset.binary_field = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ComparableUnion::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ComparableUnion");

  if (this->__isset.string_field) {
    xfer += oprot->writeFieldBegin("string_field", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->string_field);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.binary_field) {
    xfer += oprot->writeFieldBegin("binary_field", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeBinary(this->binary_field);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ComparableUnion &a, ComparableUnion &b) {
  using ::std::swap;
  swap(a.string_field, b.string_field);
  swap(a.binary_field, b.binary_field);
  swap(a.__isset, b.__isset);
}

ComparableUnion::ComparableUnion(const ComparableUnion& other605) {
  string_field = other605.string_field;
  binary_field = other605.binary_field;
  __isset = other605.__isset;
}
ComparableUnion& ComparableUnion::operator=(const ComparableUnion& other606) {
  string_field = other606.string_field;
  binary_field = other606.binary_field;
  __isset = other606.__isset;
  return *this;
}
void ComparableUnion::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ComparableUnion(";
  out << "string_field="; (__isset.string_field ? (out << to_string(string_field)) : (out << "<null>"));
  out << ", " << "binary_field="; (__isset.binary_field ? (out << to_string(binary_field)) : (out << "<null>"));
  out << ")";
}


StructWithAUnion::~StructWithAUnion() throw() {
}


void StructWithAUnion::__set_test_union(const TestUnion& val) {
  this->test_union = val;
}
std::ostream& operator<<(std::ostream& out, const StructWithAUnion& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t StructWithAUnion::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->test_union.read(iprot);
          this->__isset.test_union = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t StructWithAUnion::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("StructWithAUnion");

  xfer += oprot->writeFieldBegin("test_union", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->test_union.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(StructWithAUnion &a, StructWithAUnion &b) {
  using ::std::swap;
  swap(a.test_union, b.test_union);
  swap(a.__isset, b.__isset);
}

StructWithAUnion::StructWithAUnion(const StructWithAUnion& other607) {
  test_union = other607.test_union;
  __isset = other607.__isset;
}
StructWithAUnion& StructWithAUnion::operator=(const StructWithAUnion& other608) {
  test_union = other608.test_union;
  __isset = other608.__isset;
  return *this;
}
void StructWithAUnion::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "StructWithAUnion(";
  out << "test_union=" << to_string(test_union);
  out << ")";
}


PrimitiveThenStruct::~PrimitiveThenStruct() throw() {
}


void PrimitiveThenStruct::__set_blah(const int32_t val) {
  this->blah = val;
}

void PrimitiveThenStruct::__set_blah2(const int32_t val) {
  this->blah2 = val;
}

void PrimitiveThenStruct::__set_bw(const Backwards& val) {
  this->bw = val;
}
std::ostream& operator<<(std::ostream& out, const PrimitiveThenStruct& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PrimitiveThenStruct::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->blah);
          this->__isset.blah = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->blah2);
          this->__isset.blah2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->bw.read(iprot);
          this->__isset.bw = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PrimitiveThenStruct::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PrimitiveThenStruct");

  xfer += oprot->writeFieldBegin("blah", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->blah);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("blah2", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->blah2);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bw", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->bw.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PrimitiveThenStruct &a, PrimitiveThenStruct &b) {
  using ::std::swap;
  swap(a.blah, b.blah);
  swap(a.blah2, b.blah2);
  swap(a.bw, b.bw);
  swap(a.__isset, b.__isset);
}

PrimitiveThenStruct::PrimitiveThenStruct(const PrimitiveThenStruct& other609) {
  blah = other609.blah;
  blah2 = other609.blah2;
  bw = other609.bw;
  __isset = other609.__isset;
}
PrimitiveThenStruct& PrimitiveThenStruct::operator=(const PrimitiveThenStruct& other610) {
  blah = other610.blah;
  blah2 = other610.blah2;
  bw = other610.bw;
  __isset = other610.__isset;
  return *this;
}
void PrimitiveThenStruct::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PrimitiveThenStruct(";
  out << "blah=" << to_string(blah);
  out << ", " << "blah2=" << to_string(blah2);
  out << ", " << "bw=" << to_string(bw);
  out << ")";
}


StructWithASomemap::~StructWithASomemap() throw() {
}


void StructWithASomemap::__set_somemap_field(const SomeMap& val) {
  this->somemap_field = val;
}
std::ostream& operator<<(std::ostream& out, const StructWithASomemap& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t StructWithASomemap::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_somemap_field = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->somemap_field.clear();
            uint32_t _size611;
            ::apache::thrift::protocol::TType _ktype612;
            ::apache::thrift::protocol::TType _vtype613;
            xfer += iprot->readMapBegin(_ktype612, _vtype613, _size611);
            uint32_t _i615;
            for (_i615 = 0; _i615 < _size611; ++_i615)
            {
              int32_t _key616;
              xfer += iprot->readI32(_key616);
              int32_t& _val617 = this->somemap_field[_key616];
              xfer += iprot->readI32(_val617);
            }
            xfer += iprot->readMapEnd();
          }
          isset_somemap_field = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_somemap_field)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t StructWithASomemap::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("StructWithASomemap");

  xfer += oprot->writeFieldBegin("somemap_field", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->somemap_field.size()));
    std::map<int32_t, int32_t> ::const_iterator _iter618;
    for (_iter618 = this->somemap_field.begin(); _iter618 != this->somemap_field.end(); ++_iter618)
    {
      xfer += oprot->writeI32(_iter618->first);
      xfer += oprot->writeI32(_iter618->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(StructWithASomemap &a, StructWithASomemap &b) {
  using ::std::swap;
  swap(a.somemap_field, b.somemap_field);
}

StructWithASomemap::StructWithASomemap(const StructWithASomemap& other619) {
  somemap_field = other619.somemap_field;
}
StructWithASomemap& StructWithASomemap::operator=(const StructWithASomemap& other620) {
  somemap_field = other620.somemap_field;
  return *this;
}
void StructWithASomemap::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "StructWithASomemap(";
  out << "somemap_field=" << to_string(somemap_field);
  out << ")";
}


BigFieldIdStruct::~BigFieldIdStruct() throw() {
}


void BigFieldIdStruct::__set_field1(const std::string& val) {
  this->field1 = val;
}

void BigFieldIdStruct::__set_field2(const std::string& val) {
  this->field2 = val;
}
std::ostream& operator<<(std::ostream& out, const BigFieldIdStruct& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t BigFieldIdStruct::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->field1);
          this->__isset.field1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 45:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->field2);
          this->__isset.field2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BigFieldIdStruct::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BigFieldIdStruct");

  xfer += oprot->writeFieldBegin("field1", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->field1);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("field2", ::apache::thrift::protocol::T_STRING, 45);
  xfer += oprot->writeString(this->field2);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BigFieldIdStruct &a, BigFieldIdStruct &b) {
  using ::std::swap;
  swap(a.field1, b.field1);
  swap(a.field2, b.field2);
  swap(a.__isset, b.__isset);
}

BigFieldIdStruct::BigFieldIdStruct(const BigFieldIdStruct& other621) {
  field1 = other621.field1;
  field2 = other621.field2;
  __isset = other621.__isset;
}
BigFieldIdStruct& BigFieldIdStruct::operator=(const BigFieldIdStruct& other622) {
  field1 = other622.field1;
  field2 = other622.field2;
  __isset = other622.__isset;
  return *this;
}
void BigFieldIdStruct::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BigFieldIdStruct(";
  out << "field1=" << to_string(field1);
  out << ", " << "field2=" << to_string(field2);
  out << ")";
}


BreaksRubyCompactProtocol::~BreaksRubyCompactProtocol() throw() {
}


void BreaksRubyCompactProtocol::__set_field1(const std::string& val) {
  this->field1 = val;
}

void BreaksRubyCompactProtocol::__set_field2(const BigFieldIdStruct& val) {
  this->field2 = val;
}

void BreaksRubyCompactProtocol::__set_field3(const int32_t val) {
  this->field3 = val;
}
std::ostream& operator<<(std::ostream& out, const BreaksRubyCompactProtocol& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t BreaksRubyCompactProtocol::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->field1);
          this->__isset.field1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->field2.read(iprot);
          this->__isset.field2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->field3);
          this->__isset.field3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BreaksRubyCompactProtocol::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BreaksRubyCompactProtocol");

  xfer += oprot->writeFieldBegin("field1", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->field1);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("field2", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->field2.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("field3", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->field3);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BreaksRubyCompactProtocol &a, BreaksRubyCompactProtocol &b) {
  using ::std::swap;
  swap(a.field1, b.field1);
  swap(a.field2, b.field2);
  swap(a.field3, b.field3);
  swap(a.__isset, b.__isset);
}

BreaksRubyCompactProtocol::BreaksRubyCompactProtocol(const BreaksRubyCompactProtocol& other623) {
  field1 = other623.field1;
  field2 = other623.field2;
  field3 = other623.field3;
  __isset = other623.__isset;
}
BreaksRubyCompactProtocol& BreaksRubyCompactProtocol::operator=(const BreaksRubyCompactProtocol& other624) {
  field1 = other624.field1;
  field2 = other624.field2;
  field3 = other624.field3;
  __isset = other624.__isset;
  return *this;
}
void BreaksRubyCompactProtocol::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BreaksRubyCompactProtocol(";
  out << "field1=" << to_string(field1);
  out << ", " << "field2=" << to_string(field2);
  out << ", " << "field3=" << to_string(field3);
  out << ")";
}


TupleProtocolTestStruct::~TupleProtocolTestStruct() throw() {
}


void TupleProtocolTestStruct::__set_field1(const int32_t val) {
  this->field1 = val;
__isset.field1 = true;
}

void TupleProtocolTestStruct::__set_field2(const int32_t val) {
  this->field2 = val;
__isset.field2 = true;
}

void TupleProtocolTestStruct::__set_field3(const int32_t val) {
  this->field3 = val;
__isset.field3 = true;
}

void TupleProtocolTestStruct::__set_field4(const int32_t val) {
  this->field4 = val;
__isset.field4 = true;
}

void TupleProtocolTestStruct::__set_field5(const int32_t val) {
  this->field5 = val;
__isset.field5 = true;
}

void TupleProtocolTestStruct::__set_field6(const int32_t val) {
  this->field6 = val;
__isset.field6 = true;
}

void TupleProtocolTestStruct::__set_field7(const int32_t val) {
  this->field7 = val;
__isset.field7 = true;
}

void TupleProtocolTestStruct::__set_field8(const int32_t val) {
  this->field8 = val;
__isset.field8 = true;
}

void TupleProtocolTestStruct::__set_field9(const int32_t val) {
  this->field9 = val;
__isset.field9 = true;
}

void TupleProtocolTestStruct::__set_field10(const int32_t val) {
  this->field10 = val;
__isset.field10 = true;
}

void TupleProtocolTestStruct::__set_field11(const int32_t val) {
  this->field11 = val;
__isset.field11 = true;
}

void TupleProtocolTestStruct::__set_field12(const int32_t val) {
  this->field12 = val;
__isset.field12 = true;
}
std::ostream& operator<<(std::ostream& out, const TupleProtocolTestStruct& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TupleProtocolTestStruct::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case -1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->field1);
          this->__isset.field1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case -2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->field2);
          this->__isset.field2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case -3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->field3);
          this->__isset.field3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case -4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->field4);
          this->__isset.field4 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case -5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->field5);
          this->__isset.field5 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case -6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->field6);
          this->__isset.field6 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case -7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->field7);
          this->__isset.field7 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case -8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->field8);
          this->__isset.field8 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case -9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->field9);
          this->__isset.field9 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case -10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->field10);
          this->__isset.field10 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case -11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->field11);
          this->__isset.field11 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case -12:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->field12);
          this->__isset.field12 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TupleProtocolTestStruct::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TupleProtocolTestStruct");

  if (this->__isset.field12) {
    xfer += oprot->writeFieldBegin("field12", ::apache::thrift::protocol::T_I32, -12);
    xfer += oprot->writeI32(this->field12);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.field11) {
    xfer += oprot->writeFieldBegin("field11", ::apache::thrift::protocol::T_I32, -11);
    xfer += oprot->writeI32(this->field11);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.field10) {
    xfer += oprot->writeFieldBegin("field10", ::apache::thrift::protocol::T_I32, -10);
    xfer += oprot->writeI32(this->field10);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.field9) {
    xfer += oprot->writeFieldBegin("field9", ::apache::thrift::protocol::T_I32, -9);
    xfer += oprot->writeI32(this->field9);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.field8) {
    xfer += oprot->writeFieldBegin("field8", ::apache::thrift::protocol::T_I32, -8);
    xfer += oprot->writeI32(this->field8);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.field7) {
    xfer += oprot->writeFieldBegin("field7", ::apache::thrift::protocol::T_I32, -7);
    xfer += oprot->writeI32(this->field7);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.field6) {
    xfer += oprot->writeFieldBegin("field6", ::apache::thrift::protocol::T_I32, -6);
    xfer += oprot->writeI32(this->field6);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.field5) {
    xfer += oprot->writeFieldBegin("field5", ::apache::thrift::protocol::T_I32, -5);
    xfer += oprot->writeI32(this->field5);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.field4) {
    xfer += oprot->writeFieldBegin("field4", ::apache::thrift::protocol::T_I32, -4);
    xfer += oprot->writeI32(this->field4);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.field3) {
    xfer += oprot->writeFieldBegin("field3", ::apache::thrift::protocol::T_I32, -3);
    xfer += oprot->writeI32(this->field3);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.field2) {
    xfer += oprot->writeFieldBegin("field2", ::apache::thrift::protocol::T_I32, -2);
    xfer += oprot->writeI32(this->field2);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.field1) {
    xfer += oprot->writeFieldBegin("field1", ::apache::thrift::protocol::T_I32, -1);
    xfer += oprot->writeI32(this->field1);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TupleProtocolTestStruct &a, TupleProtocolTestStruct &b) {
  using ::std::swap;
  swap(a.field1, b.field1);
  swap(a.field2, b.field2);
  swap(a.field3, b.field3);
  swap(a.field4, b.field4);
  swap(a.field5, b.field5);
  swap(a.field6, b.field6);
  swap(a.field7, b.field7);
  swap(a.field8, b.field8);
  swap(a.field9, b.field9);
  swap(a.field10, b.field10);
  swap(a.field11, b.field11);
  swap(a.field12, b.field12);
  swap(a.__isset, b.__isset);
}

TupleProtocolTestStruct::TupleProtocolTestStruct(const TupleProtocolTestStruct& other625) {
  field1 = other625.field1;
  field2 = other625.field2;
  field3 = other625.field3;
  field4 = other625.field4;
  field5 = other625.field5;
  field6 = other625.field6;
  field7 = other625.field7;
  field8 = other625.field8;
  field9 = other625.field9;
  field10 = other625.field10;
  field11 = other625.field11;
  field12 = other625.field12;
  __isset = other625.__isset;
}
TupleProtocolTestStruct& TupleProtocolTestStruct::operator=(const TupleProtocolTestStruct& other626) {
  field1 = other626.field1;
  field2 = other626.field2;
  field3 = other626.field3;
  field4 = other626.field4;
  field5 = other626.field5;
  field6 = other626.field6;
  field7 = other626.field7;
  field8 = other626.field8;
  field9 = other626.field9;
  field10 = other626.field10;
  field11 = other626.field11;
  field12 = other626.field12;
  __isset = other626.__isset;
  return *this;
}
void TupleProtocolTestStruct::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TupleProtocolTestStruct(";
  out << "field1="; (__isset.field1 ? (out << to_string(field1)) : (out << "<null>"));
  out << ", " << "field2="; (__isset.field2 ? (out << to_string(field2)) : (out << "<null>"));
  out << ", " << "field3="; (__isset.field3 ? (out << to_string(field3)) : (out << "<null>"));
  out << ", " << "field4="; (__isset.field4 ? (out << to_string(field4)) : (out << "<null>"));
  out << ", " << "field5="; (__isset.field5 ? (out << to_string(field5)) : (out << "<null>"));
  out << ", " << "field6="; (__isset.field6 ? (out << to_string(field6)) : (out << "<null>"));
  out << ", " << "field7="; (__isset.field7 ? (out << to_string(field7)) : (out << "<null>"));
  out << ", " << "field8="; (__isset.field8 ? (out << to_string(field8)) : (out << "<null>"));
  out << ", " << "field9="; (__isset.field9 ? (out << to_string(field9)) : (out << "<null>"));
  out << ", " << "field10="; (__isset.field10 ? (out << to_string(field10)) : (out << "<null>"));
  out << ", " << "field11="; (__isset.field11 ? (out << to_string(field11)) : (out << "<null>"));
  out << ", " << "field12="; (__isset.field12 ? (out << to_string(field12)) : (out << "<null>"));
  out << ")";
}


ListDoublePerf::~ListDoublePerf() throw() {
}


void ListDoublePerf::__set_field(const std::vector<double> & val) {
  this->field = val;
}
std::ostream& operator<<(std::ostream& out, const ListDoublePerf& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ListDoublePerf::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->field.clear();
            uint32_t _size627;
            ::apache::thrift::protocol::TType _etype630;
            xfer += iprot->readListBegin(_etype630, _size627);
            this->field.resize(_size627);
            uint32_t _i631;
            for (_i631 = 0; _i631 < _size627; ++_i631)
            {
              xfer += iprot->readDouble(this->field[_i631]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.field = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ListDoublePerf::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ListDoublePerf");

  xfer += oprot->writeFieldBegin("field", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->field.size()));
    std::vector<double> ::const_iterator _iter632;
    for (_iter632 = this->field.begin(); _iter632 != this->field.end(); ++_iter632)
    {
      xfer += oprot->writeDouble((*_iter632));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ListDoublePerf &a, ListDoublePerf &b) {
  using ::std::swap;
  swap(a.field, b.field);
  swap(a.__isset, b.__isset);
}

ListDoublePerf::ListDoublePerf(const ListDoublePerf& other633) {
  field = other633.field;
  __isset = other633.__isset;
}
ListDoublePerf& ListDoublePerf::operator=(const ListDoublePerf& other634) {
  field = other634.field;
  __isset = other634.__isset;
  return *this;
}
void ListDoublePerf::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ListDoublePerf(";
  out << "field=" << to_string(field);
  out << ")";
}

}}} // namespace
