/**
 * Autogenerated by Thrift Compiler (1.0.0-dev)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "ThriftTest_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace thrift { namespace test {

int _kNumberzValues[] = {
  Numberz::ONE,
  Numberz::TWO,
  Numberz::THREE,
  Numberz::FIVE,
  Numberz::SIX,
  Numberz::EIGHT
};
const char* _kNumberzNames[] = {
  "ONE",
  "TWO",
  "THREE",
  "FIVE",
  "SIX",
  "EIGHT"
};
const std::map<int, const char*> _Numberz_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kNumberzValues, _kNumberzNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const Numberz::type& val) {
  std::map<int, const char*>::const_iterator it = _Numberz_VALUES_TO_NAMES.find(val);
  if (it != _Numberz_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}


Bonk::~Bonk() throw() {
}


void Bonk::__set_message(const std::string& val) {
  this->message = val;
}

void Bonk::__set_type(const int32_t val) {
  this->type = val;
}
std::ostream& operator<<(std::ostream& out, const Bonk& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Bonk::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Bonk::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Bonk");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Bonk &a, Bonk &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.type, b.type);
  swap(a.__isset, b.__isset);
}

Bonk::Bonk(const Bonk& other0) {
  message = other0.message;
  type = other0.type;
  __isset = other0.__isset;
}
Bonk& Bonk::operator=(const Bonk& other1) {
  message = other1.message;
  type = other1.type;
  __isset = other1.__isset;
  return *this;
}
void Bonk::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Bonk(";
  out << "message=" << to_string(message);
  out << ", " << "type=" << to_string(type);
  out << ")";
}


Bools::~Bools() throw() {
}


void Bools::__set_im_true(const bool val) {
  this->im_true = val;
}

void Bools::__set_im_false(const bool val) {
  this->im_false = val;
}
std::ostream& operator<<(std::ostream& out, const Bools& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Bools::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->im_true);
          this->__isset.im_true = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->im_false);
          this->__isset.im_false = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Bools::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Bools");

  xfer += oprot->writeFieldBegin("im_true", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->im_true);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("im_false", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->im_false);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Bools &a, Bools &b) {
  using ::std::swap;
  swap(a.im_true, b.im_true);
  swap(a.im_false, b.im_false);
  swap(a.__isset, b.__isset);
}

Bools::Bools(const Bools& other2) {
  im_true = other2.im_true;
  im_false = other2.im_false;
  __isset = other2.__isset;
}
Bools& Bools::operator=(const Bools& other3) {
  im_true = other3.im_true;
  im_false = other3.im_false;
  __isset = other3.__isset;
  return *this;
}
void Bools::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Bools(";
  out << "im_true=" << to_string(im_true);
  out << ", " << "im_false=" << to_string(im_false);
  out << ")";
}


Xtruct::~Xtruct() throw() {
}


void Xtruct::__set_string_thing(const std::string& val) {
  this->string_thing = val;
}

void Xtruct::__set_byte_thing(const int8_t val) {
  this->byte_thing = val;
}

void Xtruct::__set_i32_thing(const int32_t val) {
  this->i32_thing = val;
}

void Xtruct::__set_i64_thing(const int64_t val) {
  this->i64_thing = val;
}
std::ostream& operator<<(std::ostream& out, const Xtruct& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Xtruct::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->string_thing);
          this->__isset.string_thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->byte_thing);
          this->__isset.byte_thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->i32_thing);
          this->__isset.i32_thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->i64_thing);
          this->__isset.i64_thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Xtruct::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Xtruct");

  xfer += oprot->writeFieldBegin("string_thing", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->string_thing);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("byte_thing", ::apache::thrift::protocol::T_BYTE, 4);
  xfer += oprot->writeByte(this->byte_thing);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("i32_thing", ::apache::thrift::protocol::T_I32, 9);
  xfer += oprot->writeI32(this->i32_thing);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("i64_thing", ::apache::thrift::protocol::T_I64, 11);
  xfer += oprot->writeI64(this->i64_thing);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Xtruct &a, Xtruct &b) {
  using ::std::swap;
  swap(a.string_thing, b.string_thing);
  swap(a.byte_thing, b.byte_thing);
  swap(a.i32_thing, b.i32_thing);
  swap(a.i64_thing, b.i64_thing);
  swap(a.__isset, b.__isset);
}

Xtruct::Xtruct(const Xtruct& other4) {
  string_thing = other4.string_thing;
  byte_thing = other4.byte_thing;
  i32_thing = other4.i32_thing;
  i64_thing = other4.i64_thing;
  __isset = other4.__isset;
}
Xtruct& Xtruct::operator=(const Xtruct& other5) {
  string_thing = other5.string_thing;
  byte_thing = other5.byte_thing;
  i32_thing = other5.i32_thing;
  i64_thing = other5.i64_thing;
  __isset = other5.__isset;
  return *this;
}
void Xtruct::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Xtruct(";
  out << "string_thing=" << to_string(string_thing);
  out << ", " << "byte_thing=" << to_string(byte_thing);
  out << ", " << "i32_thing=" << to_string(i32_thing);
  out << ", " << "i64_thing=" << to_string(i64_thing);
  out << ")";
}


Xtruct2::~Xtruct2() throw() {
}


void Xtruct2::__set_byte_thing(const int8_t val) {
  this->byte_thing = val;
}

void Xtruct2::__set_struct_thing(const Xtruct& val) {
  this->struct_thing = val;
}

void Xtruct2::__set_i32_thing(const int32_t val) {
  this->i32_thing = val;
}
std::ostream& operator<<(std::ostream& out, const Xtruct2& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Xtruct2::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->byte_thing);
          this->__isset.byte_thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->struct_thing.read(iprot);
          this->__isset.struct_thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->i32_thing);
          this->__isset.i32_thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Xtruct2::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Xtruct2");

  xfer += oprot->writeFieldBegin("byte_thing", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->byte_thing);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("struct_thing", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->struct_thing.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("i32_thing", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->i32_thing);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Xtruct2 &a, Xtruct2 &b) {
  using ::std::swap;
  swap(a.byte_thing, b.byte_thing);
  swap(a.struct_thing, b.struct_thing);
  swap(a.i32_thing, b.i32_thing);
  swap(a.__isset, b.__isset);
}

Xtruct2::Xtruct2(const Xtruct2& other6) {
  byte_thing = other6.byte_thing;
  struct_thing = other6.struct_thing;
  i32_thing = other6.i32_thing;
  __isset = other6.__isset;
}
Xtruct2& Xtruct2::operator=(const Xtruct2& other7) {
  byte_thing = other7.byte_thing;
  struct_thing = other7.struct_thing;
  i32_thing = other7.i32_thing;
  __isset = other7.__isset;
  return *this;
}
void Xtruct2::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Xtruct2(";
  out << "byte_thing=" << to_string(byte_thing);
  out << ", " << "struct_thing=" << to_string(struct_thing);
  out << ", " << "i32_thing=" << to_string(i32_thing);
  out << ")";
}


Xtruct3::~Xtruct3() throw() {
}


void Xtruct3::__set_string_thing(const std::string& val) {
  this->string_thing = val;
}

void Xtruct3::__set_changed(const int32_t val) {
  this->changed = val;
}

void Xtruct3::__set_i32_thing(const int32_t val) {
  this->i32_thing = val;
}

void Xtruct3::__set_i64_thing(const int64_t val) {
  this->i64_thing = val;
}
std::ostream& operator<<(std::ostream& out, const Xtruct3& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Xtruct3::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->string_thing);
          this->__isset.string_thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->changed);
          this->__isset.changed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->i32_thing);
          this->__isset.i32_thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->i64_thing);
          this->__isset.i64_thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Xtruct3::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Xtruct3");

  xfer += oprot->writeFieldBegin("string_thing", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->string_thing);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("changed", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->changed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("i32_thing", ::apache::thrift::protocol::T_I32, 9);
  xfer += oprot->writeI32(this->i32_thing);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("i64_thing", ::apache::thrift::protocol::T_I64, 11);
  xfer += oprot->writeI64(this->i64_thing);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Xtruct3 &a, Xtruct3 &b) {
  using ::std::swap;
  swap(a.string_thing, b.string_thing);
  swap(a.changed, b.changed);
  swap(a.i32_thing, b.i32_thing);
  swap(a.i64_thing, b.i64_thing);
  swap(a.__isset, b.__isset);
}

Xtruct3::Xtruct3(const Xtruct3& other8) {
  string_thing = other8.string_thing;
  changed = other8.changed;
  i32_thing = other8.i32_thing;
  i64_thing = other8.i64_thing;
  __isset = other8.__isset;
}
Xtruct3& Xtruct3::operator=(const Xtruct3& other9) {
  string_thing = other9.string_thing;
  changed = other9.changed;
  i32_thing = other9.i32_thing;
  i64_thing = other9.i64_thing;
  __isset = other9.__isset;
  return *this;
}
void Xtruct3::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Xtruct3(";
  out << "string_thing=" << to_string(string_thing);
  out << ", " << "changed=" << to_string(changed);
  out << ", " << "i32_thing=" << to_string(i32_thing);
  out << ", " << "i64_thing=" << to_string(i64_thing);
  out << ")";
}


Insanity::~Insanity() throw() {
}


void Insanity::__set_userMap(const std::map<Numberz::type, UserId> & val) {
  this->userMap = val;
}

void Insanity::__set_xtructs(const std::vector<Xtruct> & val) {
  this->xtructs = val;
}
std::ostream& operator<<(std::ostream& out, const Insanity& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Insanity::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->userMap.clear();
            uint32_t _size10;
            ::apache::thrift::protocol::TType _ktype11;
            ::apache::thrift::protocol::TType _vtype12;
            xfer += iprot->readMapBegin(_ktype11, _vtype12, _size10);
            uint32_t _i14;
            for (_i14 = 0; _i14 < _size10; ++_i14)
            {
              Numberz::type _key15;
              int32_t ecast17;
              xfer += iprot->readI32(ecast17);
              _key15 = (Numberz::type)ecast17;
              UserId& _val16 = this->userMap[_key15];
              xfer += iprot->readI64(_val16);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.userMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->xtructs.clear();
            uint32_t _size18;
            ::apache::thrift::protocol::TType _etype21;
            xfer += iprot->readListBegin(_etype21, _size18);
            this->xtructs.resize(_size18);
            uint32_t _i22;
            for (_i22 = 0; _i22 < _size18; ++_i22)
            {
              xfer += this->xtructs[_i22].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.xtructs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Insanity::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Insanity");

  xfer += oprot->writeFieldBegin("userMap", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->userMap.size()));
    std::map<Numberz::type, UserId> ::const_iterator _iter23;
    for (_iter23 = this->userMap.begin(); _iter23 != this->userMap.end(); ++_iter23)
    {
      xfer += oprot->writeI32((int32_t)_iter23->first);
      xfer += oprot->writeI64(_iter23->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("xtructs", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->xtructs.size()));
    std::vector<Xtruct> ::const_iterator _iter24;
    for (_iter24 = this->xtructs.begin(); _iter24 != this->xtructs.end(); ++_iter24)
    {
      xfer += (*_iter24).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Insanity &a, Insanity &b) {
  using ::std::swap;
  swap(a.userMap, b.userMap);
  swap(a.xtructs, b.xtructs);
  swap(a.__isset, b.__isset);
}

Insanity::Insanity(const Insanity& other25) {
  userMap = other25.userMap;
  xtructs = other25.xtructs;
  __isset = other25.__isset;
}
Insanity& Insanity::operator=(const Insanity& other26) {
  userMap = other26.userMap;
  xtructs = other26.xtructs;
  __isset = other26.__isset;
  return *this;
}
void Insanity::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Insanity(";
  out << "userMap=" << to_string(userMap);
  out << ", " << "xtructs=" << to_string(xtructs);
  out << ")";
}


CrazyNesting::~CrazyNesting() throw() {
}


void CrazyNesting::__set_string_field(const std::string& val) {
  this->string_field = val;
}

void CrazyNesting::__set_set_field(const std::set<Insanity> & val) {
  this->set_field = val;
__isset.set_field = true;
}

void CrazyNesting::__set_list_field(const std::vector<std::map<std::set<int32_t> , std::map<int32_t, std::set<std::vector<std::map<Insanity, std::string> > > > > > & val) {
  this->list_field = val;
}

void CrazyNesting::__set_binary_field(const std::string& val) {
  this->binary_field = val;
}
std::ostream& operator<<(std::ostream& out, const CrazyNesting& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CrazyNesting::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_list_field = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->string_field);
          this->__isset.string_field = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->set_field.clear();
            uint32_t _size27;
            ::apache::thrift::protocol::TType _etype30;
            xfer += iprot->readSetBegin(_etype30, _size27);
            uint32_t _i31;
            for (_i31 = 0; _i31 < _size27; ++_i31)
            {
              Insanity _elem32;
              xfer += _elem32.read(iprot);
              this->set_field.insert(_elem32);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.set_field = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->list_field.clear();
            uint32_t _size33;
            ::apache::thrift::protocol::TType _etype36;
            xfer += iprot->readListBegin(_etype36, _size33);
            this->list_field.resize(_size33);
            uint32_t _i37;
            for (_i37 = 0; _i37 < _size33; ++_i37)
            {
              {
                this->list_field[_i37].clear();
                uint32_t _size38;
                ::apache::thrift::protocol::TType _ktype39;
                ::apache::thrift::protocol::TType _vtype40;
                xfer += iprot->readMapBegin(_ktype39, _vtype40, _size38);
                uint32_t _i42;
                for (_i42 = 0; _i42 < _size38; ++_i42)
                {
                  std::set<int32_t>  _key43;
                  {
                    _key43.clear();
                    uint32_t _size45;
                    ::apache::thrift::protocol::TType _etype48;
                    xfer += iprot->readSetBegin(_etype48, _size45);
                    uint32_t _i49;
                    for (_i49 = 0; _i49 < _size45; ++_i49)
                    {
                      int32_t _elem50;
                      xfer += iprot->readI32(_elem50);
                      _key43.insert(_elem50);
                    }
                    xfer += iprot->readSetEnd();
                  }
                  std::map<int32_t, std::set<std::vector<std::map<Insanity, std::string> > > > & _val44 = this->list_field[_i37][_key43];
                  {
                    _val44.clear();
                    uint32_t _size51;
                    ::apache::thrift::protocol::TType _ktype52;
                    ::apache::thrift::protocol::TType _vtype53;
                    xfer += iprot->readMapBegin(_ktype52, _vtype53, _size51);
                    uint32_t _i55;
                    for (_i55 = 0; _i55 < _size51; ++_i55)
                    {
                      int32_t _key56;
                      xfer += iprot->readI32(_key56);
                      std::set<std::vector<std::map<Insanity, std::string> > > & _val57 = _val44[_key56];
                      {
                        _val57.clear();
                        uint32_t _size58;
                        ::apache::thrift::protocol::TType _etype61;
                        xfer += iprot->readSetBegin(_etype61, _size58);
                        uint32_t _i62;
                        for (_i62 = 0; _i62 < _size58; ++_i62)
                        {
                          std::vector<std::map<Insanity, std::string> >  _elem63;
                          {
                            _elem63.clear();
                            uint32_t _size64;
                            ::apache::thrift::protocol::TType _etype67;
                            xfer += iprot->readListBegin(_etype67, _size64);
                            _elem63.resize(_size64);
                            uint32_t _i68;
                            for (_i68 = 0; _i68 < _size64; ++_i68)
                            {
                              {
                                _elem63[_i68].clear();
                                uint32_t _size69;
                                ::apache::thrift::protocol::TType _ktype70;
                                ::apache::thrift::protocol::TType _vtype71;
                                xfer += iprot->readMapBegin(_ktype70, _vtype71, _size69);
                                uint32_t _i73;
                                for (_i73 = 0; _i73 < _size69; ++_i73)
                                {
                                  Insanity _key74;
                                  xfer += _key74.read(iprot);
                                  std::string& _val75 = _elem63[_i68][_key74];
                                  xfer += iprot->readString(_val75);
                                }
                                xfer += iprot->readMapEnd();
                              }
                            }
                            xfer += iprot->readListEnd();
                          }
                          _val57.insert(_elem63);
                        }
                        xfer += iprot->readSetEnd();
                      }
                    }
                    xfer += iprot->readMapEnd();
                  }
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          isset_list_field = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->binary_field);
          this->__isset.binary_field = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_list_field)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CrazyNesting::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CrazyNesting");

  xfer += oprot->writeFieldBegin("string_field", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->string_field);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.set_field) {
    xfer += oprot->writeFieldBegin("set_field", ::apache::thrift::protocol::T_SET, 2);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->set_field.size()));
      std::set<Insanity> ::const_iterator _iter76;
      for (_iter76 = this->set_field.begin(); _iter76 != this->set_field.end(); ++_iter76)
      {
        xfer += (*_iter76).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("list_field", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->list_field.size()));
    std::vector<std::map<std::set<int32_t> , std::map<int32_t, std::set<std::vector<std::map<Insanity, std::string> > > > > > ::const_iterator _iter77;
    for (_iter77 = this->list_field.begin(); _iter77 != this->list_field.end(); ++_iter77)
    {
      {
        xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_SET, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>((*_iter77).size()));
        std::map<std::set<int32_t> , std::map<int32_t, std::set<std::vector<std::map<Insanity, std::string> > > > > ::const_iterator _iter78;
        for (_iter78 = (*_iter77).begin(); _iter78 != (*_iter77).end(); ++_iter78)
        {
          {
            xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(_iter78->first.size()));
            std::set<int32_t> ::const_iterator _iter79;
            for (_iter79 = _iter78->first.begin(); _iter79 != _iter78->first.end(); ++_iter79)
            {
              xfer += oprot->writeI32((*_iter79));
            }
            xfer += oprot->writeSetEnd();
          }
          {
            xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_SET, static_cast<uint32_t>(_iter78->second.size()));
            std::map<int32_t, std::set<std::vector<std::map<Insanity, std::string> > > > ::const_iterator _iter80;
            for (_iter80 = _iter78->second.begin(); _iter80 != _iter78->second.end(); ++_iter80)
            {
              xfer += oprot->writeI32(_iter80->first);
              {
                xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(_iter80->second.size()));
                std::set<std::vector<std::map<Insanity, std::string> > > ::const_iterator _iter81;
                for (_iter81 = _iter80->second.begin(); _iter81 != _iter80->second.end(); ++_iter81)
                {
                  {
                    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_MAP, static_cast<uint32_t>((*_iter81).size()));
                    std::vector<std::map<Insanity, std::string> > ::const_iterator _iter82;
                    for (_iter82 = (*_iter81).begin(); _iter82 != (*_iter81).end(); ++_iter82)
                    {
                      {
                        xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRUCT, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*_iter82).size()));
                        std::map<Insanity, std::string> ::const_iterator _iter83;
                        for (_iter83 = (*_iter82).begin(); _iter83 != (*_iter82).end(); ++_iter83)
                        {
                          xfer += _iter83->first.write(oprot);
                          xfer += oprot->writeString(_iter83->second);
                        }
                        xfer += oprot->writeMapEnd();
                      }
                    }
                    xfer += oprot->writeListEnd();
                  }
                }
                xfer += oprot->writeSetEnd();
              }
            }
            xfer += oprot->writeMapEnd();
          }
        }
        xfer += oprot->writeMapEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("binary_field", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->binary_field);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CrazyNesting &a, CrazyNesting &b) {
  using ::std::swap;
  swap(a.string_field, b.string_field);
  swap(a.set_field, b.set_field);
  swap(a.list_field, b.list_field);
  swap(a.binary_field, b.binary_field);
  swap(a.__isset, b.__isset);
}

CrazyNesting::CrazyNesting(const CrazyNesting& other84) {
  string_field = other84.string_field;
  set_field = other84.set_field;
  list_field = other84.list_field;
  binary_field = other84.binary_field;
  __isset = other84.__isset;
}
CrazyNesting& CrazyNesting::operator=(const CrazyNesting& other85) {
  string_field = other85.string_field;
  set_field = other85.set_field;
  list_field = other85.list_field;
  binary_field = other85.binary_field;
  __isset = other85.__isset;
  return *this;
}
void CrazyNesting::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CrazyNesting(";
  out << "string_field=" << to_string(string_field);
  out << ", " << "set_field="; (__isset.set_field ? (out << to_string(set_field)) : (out << "<null>"));
  out << ", " << "list_field=" << to_string(list_field);
  out << ", " << "binary_field=" << to_string(binary_field);
  out << ")";
}


SomeUnion::~SomeUnion() throw() {
}


void SomeUnion::__set_map_thing(const std::map<Numberz::type, UserId> & val) {
  this->map_thing = val;
__isset.map_thing = true;
}

void SomeUnion::__set_string_thing(const std::string& val) {
  this->string_thing = val;
__isset.string_thing = true;
}

void SomeUnion::__set_i32_thing(const int32_t val) {
  this->i32_thing = val;
__isset.i32_thing = true;
}

void SomeUnion::__set_xtruct_thing(const Xtruct3& val) {
  this->xtruct_thing = val;
__isset.xtruct_thing = true;
}

void SomeUnion::__set_insanity_thing(const Insanity& val) {
  this->insanity_thing = val;
__isset.insanity_thing = true;
}
std::ostream& operator<<(std::ostream& out, const SomeUnion& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SomeUnion::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->map_thing.clear();
            uint32_t _size86;
            ::apache::thrift::protocol::TType _ktype87;
            ::apache::thrift::protocol::TType _vtype88;
            xfer += iprot->readMapBegin(_ktype87, _vtype88, _size86);
            uint32_t _i90;
            for (_i90 = 0; _i90 < _size86; ++_i90)
            {
              Numberz::type _key91;
              int32_t ecast93;
              xfer += iprot->readI32(ecast93);
              _key91 = (Numberz::type)ecast93;
              UserId& _val92 = this->map_thing[_key91];
              xfer += iprot->readI64(_val92);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.map_thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->string_thing);
          this->__isset.string_thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->i32_thing);
          this->__isset.i32_thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->xtruct_thing.read(iprot);
          this->__isset.xtruct_thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->insanity_thing.read(iprot);
          this->__isset.insanity_thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SomeUnion::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SomeUnion");

  if (this->__isset.map_thing) {
    xfer += oprot->writeFieldBegin("map_thing", ::apache::thrift::protocol::T_MAP, 1);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->map_thing.size()));
      std::map<Numberz::type, UserId> ::const_iterator _iter94;
      for (_iter94 = this->map_thing.begin(); _iter94 != this->map_thing.end(); ++_iter94)
      {
        xfer += oprot->writeI32((int32_t)_iter94->first);
        xfer += oprot->writeI64(_iter94->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.string_thing) {
    xfer += oprot->writeFieldBegin("string_thing", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->string_thing);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.i32_thing) {
    xfer += oprot->writeFieldBegin("i32_thing", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->i32_thing);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.xtruct_thing) {
    xfer += oprot->writeFieldBegin("xtruct_thing", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->xtruct_thing.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.insanity_thing) {
    xfer += oprot->writeFieldBegin("insanity_thing", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->insanity_thing.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SomeUnion &a, SomeUnion &b) {
  using ::std::swap;
  swap(a.map_thing, b.map_thing);
  swap(a.string_thing, b.string_thing);
  swap(a.i32_thing, b.i32_thing);
  swap(a.xtruct_thing, b.xtruct_thing);
  swap(a.insanity_thing, b.insanity_thing);
  swap(a.__isset, b.__isset);
}

SomeUnion::SomeUnion(const SomeUnion& other95) {
  map_thing = other95.map_thing;
  string_thing = other95.string_thing;
  i32_thing = other95.i32_thing;
  xtruct_thing = other95.xtruct_thing;
  insanity_thing = other95.insanity_thing;
  __isset = other95.__isset;
}
SomeUnion& SomeUnion::operator=(const SomeUnion& other96) {
  map_thing = other96.map_thing;
  string_thing = other96.string_thing;
  i32_thing = other96.i32_thing;
  xtruct_thing = other96.xtruct_thing;
  insanity_thing = other96.insanity_thing;
  __isset = other96.__isset;
  return *this;
}
void SomeUnion::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SomeUnion(";
  out << "map_thing="; (__isset.map_thing ? (out << to_string(map_thing)) : (out << "<null>"));
  out << ", " << "string_thing="; (__isset.string_thing ? (out << to_string(string_thing)) : (out << "<null>"));
  out << ", " << "i32_thing="; (__isset.i32_thing ? (out << to_string(i32_thing)) : (out << "<null>"));
  out << ", " << "xtruct_thing="; (__isset.xtruct_thing ? (out << to_string(xtruct_thing)) : (out << "<null>"));
  out << ", " << "insanity_thing="; (__isset.insanity_thing ? (out << to_string(insanity_thing)) : (out << "<null>"));
  out << ")";
}


Xception::~Xception() throw() {
}


void Xception::__set_errorCode(const int32_t val) {
  this->errorCode = val;
}

void Xception::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const Xception& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Xception::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->errorCode);
          this->__isset.errorCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Xception::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Xception");

  xfer += oprot->writeFieldBegin("errorCode", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->errorCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Xception &a, Xception &b) {
  using ::std::swap;
  swap(a.errorCode, b.errorCode);
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

Xception::Xception(const Xception& other97) : TException() {
  errorCode = other97.errorCode;
  message = other97.message;
  __isset = other97.__isset;
}
Xception& Xception::operator=(const Xception& other98) {
  errorCode = other98.errorCode;
  message = other98.message;
  __isset = other98.__isset;
  return *this;
}
void Xception::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Xception(";
  out << "errorCode=" << to_string(errorCode);
  out << ", " << "message=" << to_string(message);
  out << ")";
}

const char* Xception::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: Xception";
  }
}


Xception2::~Xception2() throw() {
}


void Xception2::__set_errorCode(const int32_t val) {
  this->errorCode = val;
}

void Xception2::__set_struct_thing(const Xtruct& val) {
  this->struct_thing = val;
}
std::ostream& operator<<(std::ostream& out, const Xception2& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Xception2::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->errorCode);
          this->__isset.errorCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->struct_thing.read(iprot);
          this->__isset.struct_thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Xception2::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Xception2");

  xfer += oprot->writeFieldBegin("errorCode", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->errorCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("struct_thing", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->struct_thing.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Xception2 &a, Xception2 &b) {
  using ::std::swap;
  swap(a.errorCode, b.errorCode);
  swap(a.struct_thing, b.struct_thing);
  swap(a.__isset, b.__isset);
}

Xception2::Xception2(const Xception2& other99) : TException() {
  errorCode = other99.errorCode;
  struct_thing = other99.struct_thing;
  __isset = other99.__isset;
}
Xception2& Xception2::operator=(const Xception2& other100) {
  errorCode = other100.errorCode;
  struct_thing = other100.struct_thing;
  __isset = other100.__isset;
  return *this;
}
void Xception2::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Xception2(";
  out << "errorCode=" << to_string(errorCode);
  out << ", " << "struct_thing=" << to_string(struct_thing);
  out << ")";
}

const char* Xception2::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: Xception2";
  }
}


EmptyStruct::~EmptyStruct() throw() {
}

std::ostream& operator<<(std::ostream& out, const EmptyStruct& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t EmptyStruct::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t EmptyStruct::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("EmptyStruct");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(EmptyStruct &a, EmptyStruct &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

EmptyStruct::EmptyStruct(const EmptyStruct& other101) {
  (void) other101;
}
EmptyStruct& EmptyStruct::operator=(const EmptyStruct& other102) {
  (void) other102;
  return *this;
}
void EmptyStruct::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "EmptyStruct(";
  out << ")";
}


OneField::~OneField() throw() {
}


void OneField::__set_field(const EmptyStruct& val) {
  this->field = val;
}
std::ostream& operator<<(std::ostream& out, const OneField& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t OneField::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->field.read(iprot);
          this->__isset.field = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t OneField::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("OneField");

  xfer += oprot->writeFieldBegin("field", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->field.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(OneField &a, OneField &b) {
  using ::std::swap;
  swap(a.field, b.field);
  swap(a.__isset, b.__isset);
}

OneField::OneField(const OneField& other103) {
  field = other103.field;
  __isset = other103.__isset;
}
OneField& OneField::operator=(const OneField& other104) {
  field = other104.field;
  __isset = other104.__isset;
  return *this;
}
void OneField::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "OneField(";
  out << "field=" << to_string(field);
  out << ")";
}


VersioningTestV1::~VersioningTestV1() throw() {
}


void VersioningTestV1::__set_begin_in_both(const int32_t val) {
  this->begin_in_both = val;
}

void VersioningTestV1::__set_old_string(const std::string& val) {
  this->old_string = val;
}

void VersioningTestV1::__set_end_in_both(const int32_t val) {
  this->end_in_both = val;
}
std::ostream& operator<<(std::ostream& out, const VersioningTestV1& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t VersioningTestV1::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->begin_in_both);
          this->__isset.begin_in_both = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->old_string);
          this->__isset.old_string = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->end_in_both);
          this->__isset.end_in_both = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t VersioningTestV1::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("VersioningTestV1");

  xfer += oprot->writeFieldBegin("begin_in_both", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->begin_in_both);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("old_string", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->old_string);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("end_in_both", ::apache::thrift::protocol::T_I32, 12);
  xfer += oprot->writeI32(this->end_in_both);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(VersioningTestV1 &a, VersioningTestV1 &b) {
  using ::std::swap;
  swap(a.begin_in_both, b.begin_in_both);
  swap(a.old_string, b.old_string);
  swap(a.end_in_both, b.end_in_both);
  swap(a.__isset, b.__isset);
}

VersioningTestV1::VersioningTestV1(const VersioningTestV1& other105) {
  begin_in_both = other105.begin_in_both;
  old_string = other105.old_string;
  end_in_both = other105.end_in_both;
  __isset = other105.__isset;
}
VersioningTestV1& VersioningTestV1::operator=(const VersioningTestV1& other106) {
  begin_in_both = other106.begin_in_both;
  old_string = other106.old_string;
  end_in_both = other106.end_in_both;
  __isset = other106.__isset;
  return *this;
}
void VersioningTestV1::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "VersioningTestV1(";
  out << "begin_in_both=" << to_string(begin_in_both);
  out << ", " << "old_string=" << to_string(old_string);
  out << ", " << "end_in_both=" << to_string(end_in_both);
  out << ")";
}


VersioningTestV2::~VersioningTestV2() throw() {
}


void VersioningTestV2::__set_begin_in_both(const int32_t val) {
  this->begin_in_both = val;
}

void VersioningTestV2::__set_newint(const int32_t val) {
  this->newint = val;
}

void VersioningTestV2::__set_newbyte(const int8_t val) {
  this->newbyte = val;
}

void VersioningTestV2::__set_newshort(const int16_t val) {
  this->newshort = val;
}

void VersioningTestV2::__set_newlong(const int64_t val) {
  this->newlong = val;
}

void VersioningTestV2::__set_newdouble(const double val) {
  this->newdouble = val;
}

void VersioningTestV2::__set_newstruct(const Bonk& val) {
  this->newstruct = val;
}

void VersioningTestV2::__set_newlist(const std::vector<int32_t> & val) {
  this->newlist = val;
}

void VersioningTestV2::__set_newset(const std::set<int32_t> & val) {
  this->newset = val;
}

void VersioningTestV2::__set_newmap(const std::map<int32_t, int32_t> & val) {
  this->newmap = val;
}

void VersioningTestV2::__set_newstring(const std::string& val) {
  this->newstring = val;
}

void VersioningTestV2::__set_end_in_both(const int32_t val) {
  this->end_in_both = val;
}
std::ostream& operator<<(std::ostream& out, const VersioningTestV2& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t VersioningTestV2::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->begin_in_both);
          this->__isset.begin_in_both = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->newint);
          this->__isset.newint = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->newbyte);
          this->__isset.newbyte = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->newshort);
          this->__isset.newshort = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->newlong);
          this->__isset.newlong = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->newdouble);
          this->__isset.newdouble = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->newstruct.read(iprot);
          this->__isset.newstruct = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->newlist.clear();
            uint32_t _size107;
            ::apache::thrift::protocol::TType _etype110;
            xfer += iprot->readListBegin(_etype110, _size107);
            this->newlist.resize(_size107);
            uint32_t _i111;
            for (_i111 = 0; _i111 < _size107; ++_i111)
            {
              xfer += iprot->readI32(this->newlist[_i111]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.newlist = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->newset.clear();
            uint32_t _size112;
            ::apache::thrift::protocol::TType _etype115;
            xfer += iprot->readSetBegin(_etype115, _size112);
            uint32_t _i116;
            for (_i116 = 0; _i116 < _size112; ++_i116)
            {
              int32_t _elem117;
              xfer += iprot->readI32(_elem117);
              this->newset.insert(_elem117);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.newset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->newmap.clear();
            uint32_t _size118;
            ::apache::thrift::protocol::TType _ktype119;
            ::apache::thrift::protocol::TType _vtype120;
            xfer += iprot->readMapBegin(_ktype119, _vtype120, _size118);
            uint32_t _i122;
            for (_i122 = 0; _i122 < _size118; ++_i122)
            {
              int32_t _key123;
              xfer += iprot->readI32(_key123);
              int32_t& _val124 = this->newmap[_key123];
              xfer += iprot->readI32(_val124);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.newmap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->newstring);
          this->__isset.newstring = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->end_in_both);
          this->__isset.end_in_both = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t VersioningTestV2::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("VersioningTestV2");

  xfer += oprot->writeFieldBegin("begin_in_both", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->begin_in_both);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("newint", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->newint);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("newbyte", ::apache::thrift::protocol::T_BYTE, 3);
  xfer += oprot->writeByte(this->newbyte);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("newshort", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16(this->newshort);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("newlong", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->newlong);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("newdouble", ::apache::thrift::protocol::T_DOUBLE, 6);
  xfer += oprot->writeDouble(this->newdouble);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("newstruct", ::apache::thrift::protocol::T_STRUCT, 7);
  xfer += this->newstruct.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("newlist", ::apache::thrift::protocol::T_LIST, 8);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->newlist.size()));
    std::vector<int32_t> ::const_iterator _iter125;
    for (_iter125 = this->newlist.begin(); _iter125 != this->newlist.end(); ++_iter125)
    {
      xfer += oprot->writeI32((*_iter125));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("newset", ::apache::thrift::protocol::T_SET, 9);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->newset.size()));
    std::set<int32_t> ::const_iterator _iter126;
    for (_iter126 = this->newset.begin(); _iter126 != this->newset.end(); ++_iter126)
    {
      xfer += oprot->writeI32((*_iter126));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("newmap", ::apache::thrift::protocol::T_MAP, 10);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->newmap.size()));
    std::map<int32_t, int32_t> ::const_iterator _iter127;
    for (_iter127 = this->newmap.begin(); _iter127 != this->newmap.end(); ++_iter127)
    {
      xfer += oprot->writeI32(_iter127->first);
      xfer += oprot->writeI32(_iter127->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("newstring", ::apache::thrift::protocol::T_STRING, 11);
  xfer += oprot->writeString(this->newstring);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("end_in_both", ::apache::thrift::protocol::T_I32, 12);
  xfer += oprot->writeI32(this->end_in_both);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(VersioningTestV2 &a, VersioningTestV2 &b) {
  using ::std::swap;
  swap(a.begin_in_both, b.begin_in_both);
  swap(a.newint, b.newint);
  swap(a.newbyte, b.newbyte);
  swap(a.newshort, b.newshort);
  swap(a.newlong, b.newlong);
  swap(a.newdouble, b.newdouble);
  swap(a.newstruct, b.newstruct);
  swap(a.newlist, b.newlist);
  swap(a.newset, b.newset);
  swap(a.newmap, b.newmap);
  swap(a.newstring, b.newstring);
  swap(a.end_in_both, b.end_in_both);
  swap(a.__isset, b.__isset);
}

VersioningTestV2::VersioningTestV2(const VersioningTestV2& other128) {
  begin_in_both = other128.begin_in_both;
  newint = other128.newint;
  newbyte = other128.newbyte;
  newshort = other128.newshort;
  newlong = other128.newlong;
  newdouble = other128.newdouble;
  newstruct = other128.newstruct;
  newlist = other128.newlist;
  newset = other128.newset;
  newmap = other128.newmap;
  newstring = other128.newstring;
  end_in_both = other128.end_in_both;
  __isset = other128.__isset;
}
VersioningTestV2& VersioningTestV2::operator=(const VersioningTestV2& other129) {
  begin_in_both = other129.begin_in_both;
  newint = other129.newint;
  newbyte = other129.newbyte;
  newshort = other129.newshort;
  newlong = other129.newlong;
  newdouble = other129.newdouble;
  newstruct = other129.newstruct;
  newlist = other129.newlist;
  newset = other129.newset;
  newmap = other129.newmap;
  newstring = other129.newstring;
  end_in_both = other129.end_in_both;
  __isset = other129.__isset;
  return *this;
}
void VersioningTestV2::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "VersioningTestV2(";
  out << "begin_in_both=" << to_string(begin_in_both);
  out << ", " << "newint=" << to_string(newint);
  out << ", " << "newbyte=" << to_string(newbyte);
  out << ", " << "newshort=" << to_string(newshort);
  out << ", " << "newlong=" << to_string(newlong);
  out << ", " << "newdouble=" << to_string(newdouble);
  out << ", " << "newstruct=" << to_string(newstruct);
  out << ", " << "newlist=" << to_string(newlist);
  out << ", " << "newset=" << to_string(newset);
  out << ", " << "newmap=" << to_string(newmap);
  out << ", " << "newstring=" << to_string(newstring);
  out << ", " << "end_in_both=" << to_string(end_in_both);
  out << ")";
}


ListTypeVersioningV1::~ListTypeVersioningV1() throw() {
}


void ListTypeVersioningV1::__set_myints(const std::vector<int32_t> & val) {
  this->myints = val;
}

void ListTypeVersioningV1::__set_hello(const std::string& val) {
  this->hello = val;
}
std::ostream& operator<<(std::ostream& out, const ListTypeVersioningV1& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ListTypeVersioningV1::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->myints.clear();
            uint32_t _size130;
            ::apache::thrift::protocol::TType _etype133;
            xfer += iprot->readListBegin(_etype133, _size130);
            this->myints.resize(_size130);
            uint32_t _i134;
            for (_i134 = 0; _i134 < _size130; ++_i134)
            {
              xfer += iprot->readI32(this->myints[_i134]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.myints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hello);
          this->__isset.hello = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ListTypeVersioningV1::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ListTypeVersioningV1");

  xfer += oprot->writeFieldBegin("myints", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->myints.size()));
    std::vector<int32_t> ::const_iterator _iter135;
    for (_iter135 = this->myints.begin(); _iter135 != this->myints.end(); ++_iter135)
    {
      xfer += oprot->writeI32((*_iter135));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hello", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->hello);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ListTypeVersioningV1 &a, ListTypeVersioningV1 &b) {
  using ::std::swap;
  swap(a.myints, b.myints);
  swap(a.hello, b.hello);
  swap(a.__isset, b.__isset);
}

ListTypeVersioningV1::ListTypeVersioningV1(const ListTypeVersioningV1& other136) {
  myints = other136.myints;
  hello = other136.hello;
  __isset = other136.__isset;
}
ListTypeVersioningV1& ListTypeVersioningV1::operator=(const ListTypeVersioningV1& other137) {
  myints = other137.myints;
  hello = other137.hello;
  __isset = other137.__isset;
  return *this;
}
void ListTypeVersioningV1::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ListTypeVersioningV1(";
  out << "myints=" << to_string(myints);
  out << ", " << "hello=" << to_string(hello);
  out << ")";
}


ListTypeVersioningV2::~ListTypeVersioningV2() throw() {
}


void ListTypeVersioningV2::__set_strings(const std::vector<std::string> & val) {
  this->strings = val;
}

void ListTypeVersioningV2::__set_hello(const std::string& val) {
  this->hello = val;
}
std::ostream& operator<<(std::ostream& out, const ListTypeVersioningV2& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ListTypeVersioningV2::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->strings.clear();
            uint32_t _size138;
            ::apache::thrift::protocol::TType _etype141;
            xfer += iprot->readListBegin(_etype141, _size138);
            this->strings.resize(_size138);
            uint32_t _i142;
            for (_i142 = 0; _i142 < _size138; ++_i142)
            {
              xfer += iprot->readString(this->strings[_i142]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.strings = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hello);
          this->__isset.hello = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ListTypeVersioningV2::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ListTypeVersioningV2");

  xfer += oprot->writeFieldBegin("strings", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->strings.size()));
    std::vector<std::string> ::const_iterator _iter143;
    for (_iter143 = this->strings.begin(); _iter143 != this->strings.end(); ++_iter143)
    {
      xfer += oprot->writeString((*_iter143));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hello", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->hello);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ListTypeVersioningV2 &a, ListTypeVersioningV2 &b) {
  using ::std::swap;
  swap(a.strings, b.strings);
  swap(a.hello, b.hello);
  swap(a.__isset, b.__isset);
}

ListTypeVersioningV2::ListTypeVersioningV2(const ListTypeVersioningV2& other144) {
  strings = other144.strings;
  hello = other144.hello;
  __isset = other144.__isset;
}
ListTypeVersioningV2& ListTypeVersioningV2::operator=(const ListTypeVersioningV2& other145) {
  strings = other145.strings;
  hello = other145.hello;
  __isset = other145.__isset;
  return *this;
}
void ListTypeVersioningV2::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ListTypeVersioningV2(";
  out << "strings=" << to_string(strings);
  out << ", " << "hello=" << to_string(hello);
  out << ")";
}


GuessProtocolStruct::~GuessProtocolStruct() throw() {
}


void GuessProtocolStruct::__set_map_field(const std::map<std::string, std::string> & val) {
  this->map_field = val;
}
std::ostream& operator<<(std::ostream& out, const GuessProtocolStruct& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GuessProtocolStruct::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 7:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->map_field.clear();
            uint32_t _size146;
            ::apache::thrift::protocol::TType _ktype147;
            ::apache::thrift::protocol::TType _vtype148;
            xfer += iprot->readMapBegin(_ktype147, _vtype148, _size146);
            uint32_t _i150;
            for (_i150 = 0; _i150 < _size146; ++_i150)
            {
              std::string _key151;
              xfer += iprot->readString(_key151);
              std::string& _val152 = this->map_field[_key151];
              xfer += iprot->readString(_val152);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.map_field = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GuessProtocolStruct::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GuessProtocolStruct");

  xfer += oprot->writeFieldBegin("map_field", ::apache::thrift::protocol::T_MAP, 7);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->map_field.size()));
    std::map<std::string, std::string> ::const_iterator _iter153;
    for (_iter153 = this->map_field.begin(); _iter153 != this->map_field.end(); ++_iter153)
    {
      xfer += oprot->writeString(_iter153->first);
      xfer += oprot->writeString(_iter153->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GuessProtocolStruct &a, GuessProtocolStruct &b) {
  using ::std::swap;
  swap(a.map_field, b.map_field);
  swap(a.__isset, b.__isset);
}

GuessProtocolStruct::GuessProtocolStruct(const GuessProtocolStruct& other154) {
  map_field = other154.map_field;
  __isset = other154.__isset;
}
GuessProtocolStruct& GuessProtocolStruct::operator=(const GuessProtocolStruct& other155) {
  map_field = other155.map_field;
  __isset = other155.__isset;
  return *this;
}
void GuessProtocolStruct::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GuessProtocolStruct(";
  out << "map_field=" << to_string(map_field);
  out << ")";
}


LargeDeltas::~LargeDeltas() throw() {
}


void LargeDeltas::__set_b1(const Bools& val) {
  this->b1 = val;
}

void LargeDeltas::__set_b10(const Bools& val) {
  this->b10 = val;
}

void LargeDeltas::__set_b100(const Bools& val) {
  this->b100 = val;
}

void LargeDeltas::__set_check_true(const bool val) {
  this->check_true = val;
}

void LargeDeltas::__set_b1000(const Bools& val) {
  this->b1000 = val;
}

void LargeDeltas::__set_check_false(const bool val) {
  this->check_false = val;
}

void LargeDeltas::__set_vertwo2000(const VersioningTestV2& val) {
  this->vertwo2000 = val;
}

void LargeDeltas::__set_a_set2500(const std::set<std::string> & val) {
  this->a_set2500 = val;
}

void LargeDeltas::__set_vertwo3000(const VersioningTestV2& val) {
  this->vertwo3000 = val;
}

void LargeDeltas::__set_big_numbers(const std::vector<int32_t> & val) {
  this->big_numbers = val;
}
std::ostream& operator<<(std::ostream& out, const LargeDeltas& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LargeDeltas::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->b1.read(iprot);
          this->__isset.b1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->b10.read(iprot);
          this->__isset.b10 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 100:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->b100.read(iprot);
          this->__isset.b100 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 500:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->check_true);
          this->__isset.check_true = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1000:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->b1000.read(iprot);
          this->__isset.b1000 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1500:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->check_false);
          this->__isset.check_false = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2000:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->vertwo2000.read(iprot);
          this->__isset.vertwo2000 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2500:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->a_set2500.clear();
            uint32_t _size156;
            ::apache::thrift::protocol::TType _etype159;
            xfer += iprot->readSetBegin(_etype159, _size156);
            uint32_t _i160;
            for (_i160 = 0; _i160 < _size156; ++_i160)
            {
              std::string _elem161;
              xfer += iprot->readString(_elem161);
              this->a_set2500.insert(_elem161);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.a_set2500 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3000:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->vertwo3000.read(iprot);
          this->__isset.vertwo3000 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4000:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->big_numbers.clear();
            uint32_t _size162;
            ::apache::thrift::protocol::TType _etype165;
            xfer += iprot->readListBegin(_etype165, _size162);
            this->big_numbers.resize(_size162);
            uint32_t _i166;
            for (_i166 = 0; _i166 < _size162; ++_i166)
            {
              xfer += iprot->readI32(this->big_numbers[_i166]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.big_numbers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t LargeDeltas::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LargeDeltas");

  xfer += oprot->writeFieldBegin("b1", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->b1.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("b10", ::apache::thrift::protocol::T_STRUCT, 10);
  xfer += this->b10.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("b100", ::apache::thrift::protocol::T_STRUCT, 100);
  xfer += this->b100.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("check_true", ::apache::thrift::protocol::T_BOOL, 500);
  xfer += oprot->writeBool(this->check_true);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("b1000", ::apache::thrift::protocol::T_STRUCT, 1000);
  xfer += this->b1000.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("check_false", ::apache::thrift::protocol::T_BOOL, 1500);
  xfer += oprot->writeBool(this->check_false);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("vertwo2000", ::apache::thrift::protocol::T_STRUCT, 2000);
  xfer += this->vertwo2000.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("a_set2500", ::apache::thrift::protocol::T_SET, 2500);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->a_set2500.size()));
    std::set<std::string> ::const_iterator _iter167;
    for (_iter167 = this->a_set2500.begin(); _iter167 != this->a_set2500.end(); ++_iter167)
    {
      xfer += oprot->writeString((*_iter167));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("vertwo3000", ::apache::thrift::protocol::T_STRUCT, 3000);
  xfer += this->vertwo3000.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("big_numbers", ::apache::thrift::protocol::T_LIST, 4000);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->big_numbers.size()));
    std::vector<int32_t> ::const_iterator _iter168;
    for (_iter168 = this->big_numbers.begin(); _iter168 != this->big_numbers.end(); ++_iter168)
    {
      xfer += oprot->writeI32((*_iter168));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LargeDeltas &a, LargeDeltas &b) {
  using ::std::swap;
  swap(a.b1, b.b1);
  swap(a.b10, b.b10);
  swap(a.b100, b.b100);
  swap(a.check_true, b.check_true);
  swap(a.b1000, b.b1000);
  swap(a.check_false, b.check_false);
  swap(a.vertwo2000, b.vertwo2000);
  swap(a.a_set2500, b.a_set2500);
  swap(a.vertwo3000, b.vertwo3000);
  swap(a.big_numbers, b.big_numbers);
  swap(a.__isset, b.__isset);
}

LargeDeltas::LargeDeltas(const LargeDeltas& other169) {
  b1 = other169.b1;
  b10 = other169.b10;
  b100 = other169.b100;
  check_true = other169.check_true;
  b1000 = other169.b1000;
  check_false = other169.check_false;
  vertwo2000 = other169.vertwo2000;
  a_set2500 = other169.a_set2500;
  vertwo3000 = other169.vertwo3000;
  big_numbers = other169.big_numbers;
  __isset = other169.__isset;
}
LargeDeltas& LargeDeltas::operator=(const LargeDeltas& other170) {
  b1 = other170.b1;
  b10 = other170.b10;
  b100 = other170.b100;
  check_true = other170.check_true;
  b1000 = other170.b1000;
  check_false = other170.check_false;
  vertwo2000 = other170.vertwo2000;
  a_set2500 = other170.a_set2500;
  vertwo3000 = other170.vertwo3000;
  big_numbers = other170.big_numbers;
  __isset = other170.__isset;
  return *this;
}
void LargeDeltas::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LargeDeltas(";
  out << "b1=" << to_string(b1);
  out << ", " << "b10=" << to_string(b10);
  out << ", " << "b100=" << to_string(b100);
  out << ", " << "check_true=" << to_string(check_true);
  out << ", " << "b1000=" << to_string(b1000);
  out << ", " << "check_false=" << to_string(check_false);
  out << ", " << "vertwo2000=" << to_string(vertwo2000);
  out << ", " << "a_set2500=" << to_string(a_set2500);
  out << ", " << "vertwo3000=" << to_string(vertwo3000);
  out << ", " << "big_numbers=" << to_string(big_numbers);
  out << ")";
}


NestedListsI32x2::~NestedListsI32x2() throw() {
}


void NestedListsI32x2::__set_integerlist(const std::vector<std::vector<int32_t> > & val) {
  this->integerlist = val;
}
std::ostream& operator<<(std::ostream& out, const NestedListsI32x2& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NestedListsI32x2::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->integerlist.clear();
            uint32_t _size171;
            ::apache::thrift::protocol::TType _etype174;
            xfer += iprot->readListBegin(_etype174, _size171);
            this->integerlist.resize(_size171);
            uint32_t _i175;
            for (_i175 = 0; _i175 < _size171; ++_i175)
            {
              {
                this->integerlist[_i175].clear();
                uint32_t _size176;
                ::apache::thrift::protocol::TType _etype179;
                xfer += iprot->readListBegin(_etype179, _size176);
                this->integerlist[_i175].resize(_size176);
                uint32_t _i180;
                for (_i180 = 0; _i180 < _size176; ++_i180)
                {
                  xfer += iprot->readI32(this->integerlist[_i175][_i180]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.integerlist = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NestedListsI32x2::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NestedListsI32x2");

  xfer += oprot->writeFieldBegin("integerlist", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->integerlist.size()));
    std::vector<std::vector<int32_t> > ::const_iterator _iter181;
    for (_iter181 = this->integerlist.begin(); _iter181 != this->integerlist.end(); ++_iter181)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*_iter181).size()));
        std::vector<int32_t> ::const_iterator _iter182;
        for (_iter182 = (*_iter181).begin(); _iter182 != (*_iter181).end(); ++_iter182)
        {
          xfer += oprot->writeI32((*_iter182));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NestedListsI32x2 &a, NestedListsI32x2 &b) {
  using ::std::swap;
  swap(a.integerlist, b.integerlist);
  swap(a.__isset, b.__isset);
}

NestedListsI32x2::NestedListsI32x2(const NestedListsI32x2& other183) {
  integerlist = other183.integerlist;
  __isset = other183.__isset;
}
NestedListsI32x2& NestedListsI32x2::operator=(const NestedListsI32x2& other184) {
  integerlist = other184.integerlist;
  __isset = other184.__isset;
  return *this;
}
void NestedListsI32x2::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NestedListsI32x2(";
  out << "integerlist=" << to_string(integerlist);
  out << ")";
}


NestedListsI32x3::~NestedListsI32x3() throw() {
}


void NestedListsI32x3::__set_integerlist(const std::vector<std::vector<std::vector<int32_t> > > & val) {
  this->integerlist = val;
}
std::ostream& operator<<(std::ostream& out, const NestedListsI32x3& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NestedListsI32x3::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->integerlist.clear();
            uint32_t _size185;
            ::apache::thrift::protocol::TType _etype188;
            xfer += iprot->readListBegin(_etype188, _size185);
            this->integerlist.resize(_size185);
            uint32_t _i189;
            for (_i189 = 0; _i189 < _size185; ++_i189)
            {
              {
                this->integerlist[_i189].clear();
                uint32_t _size190;
                ::apache::thrift::protocol::TType _etype193;
                xfer += iprot->readListBegin(_etype193, _size190);
                this->integerlist[_i189].resize(_size190);
                uint32_t _i194;
                for (_i194 = 0; _i194 < _size190; ++_i194)
                {
                  {
                    this->integerlist[_i189][_i194].clear();
                    uint32_t _size195;
                    ::apache::thrift::protocol::TType _etype198;
                    xfer += iprot->readListBegin(_etype198, _size195);
                    this->integerlist[_i189][_i194].resize(_size195);
                    uint32_t _i199;
                    for (_i199 = 0; _i199 < _size195; ++_i199)
                    {
                      xfer += iprot->readI32(this->integerlist[_i189][_i194][_i199]);
                    }
                    xfer += iprot->readListEnd();
                  }
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.integerlist = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NestedListsI32x3::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NestedListsI32x3");

  xfer += oprot->writeFieldBegin("integerlist", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->integerlist.size()));
    std::vector<std::vector<std::vector<int32_t> > > ::const_iterator _iter200;
    for (_iter200 = this->integerlist.begin(); _iter200 != this->integerlist.end(); ++_iter200)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>((*_iter200).size()));
        std::vector<std::vector<int32_t> > ::const_iterator _iter201;
        for (_iter201 = (*_iter200).begin(); _iter201 != (*_iter200).end(); ++_iter201)
        {
          {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*_iter201).size()));
            std::vector<int32_t> ::const_iterator _iter202;
            for (_iter202 = (*_iter201).begin(); _iter202 != (*_iter201).end(); ++_iter202)
            {
              xfer += oprot->writeI32((*_iter202));
            }
            xfer += oprot->writeListEnd();
          }
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NestedListsI32x3 &a, NestedListsI32x3 &b) {
  using ::std::swap;
  swap(a.integerlist, b.integerlist);
  swap(a.__isset, b.__isset);
}

NestedListsI32x3::NestedListsI32x3(const NestedListsI32x3& other203) {
  integerlist = other203.integerlist;
  __isset = other203.__isset;
}
NestedListsI32x3& NestedListsI32x3::operator=(const NestedListsI32x3& other204) {
  integerlist = other204.integerlist;
  __isset = other204.__isset;
  return *this;
}
void NestedListsI32x3::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NestedListsI32x3(";
  out << "integerlist=" << to_string(integerlist);
  out << ")";
}


NestedMixedx2::~NestedMixedx2() throw() {
}


void NestedMixedx2::__set_int_set_list(const std::vector<std::set<int32_t> > & val) {
  this->int_set_list = val;
}

void NestedMixedx2::__set_map_int_strset(const std::map<int32_t, std::set<std::string> > & val) {
  this->map_int_strset = val;
}

void NestedMixedx2::__set_map_int_strset_list(const std::vector<std::map<int32_t, std::set<std::string> > > & val) {
  this->map_int_strset_list = val;
}
std::ostream& operator<<(std::ostream& out, const NestedMixedx2& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NestedMixedx2::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->int_set_list.clear();
            uint32_t _size205;
            ::apache::thrift::protocol::TType _etype208;
            xfer += iprot->readListBegin(_etype208, _size205);
            this->int_set_list.resize(_size205);
            uint32_t _i209;
            for (_i209 = 0; _i209 < _size205; ++_i209)
            {
              {
                this->int_set_list[_i209].clear();
                uint32_t _size210;
                ::apache::thrift::protocol::TType _etype213;
                xfer += iprot->readSetBegin(_etype213, _size210);
                uint32_t _i214;
                for (_i214 = 0; _i214 < _size210; ++_i214)
                {
                  int32_t _elem215;
                  xfer += iprot->readI32(_elem215);
                  this->int_set_list[_i209].insert(_elem215);
                }
                xfer += iprot->readSetEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.int_set_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->map_int_strset.clear();
            uint32_t _size216;
            ::apache::thrift::protocol::TType _ktype217;
            ::apache::thrift::protocol::TType _vtype218;
            xfer += iprot->readMapBegin(_ktype217, _vtype218, _size216);
            uint32_t _i220;
            for (_i220 = 0; _i220 < _size216; ++_i220)
            {
              int32_t _key221;
              xfer += iprot->readI32(_key221);
              std::set<std::string> & _val222 = this->map_int_strset[_key221];
              {
                _val222.clear();
                uint32_t _size223;
                ::apache::thrift::protocol::TType _etype226;
                xfer += iprot->readSetBegin(_etype226, _size223);
                uint32_t _i227;
                for (_i227 = 0; _i227 < _size223; ++_i227)
                {
                  std::string _elem228;
                  xfer += iprot->readString(_elem228);
                  _val222.insert(_elem228);
                }
                xfer += iprot->readSetEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.map_int_strset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->map_int_strset_list.clear();
            uint32_t _size229;
            ::apache::thrift::protocol::TType _etype232;
            xfer += iprot->readListBegin(_etype232, _size229);
            this->map_int_strset_list.resize(_size229);
            uint32_t _i233;
            for (_i233 = 0; _i233 < _size229; ++_i233)
            {
              {
                this->map_int_strset_list[_i233].clear();
                uint32_t _size234;
                ::apache::thrift::protocol::TType _ktype235;
                ::apache::thrift::protocol::TType _vtype236;
                xfer += iprot->readMapBegin(_ktype235, _vtype236, _size234);
                uint32_t _i238;
                for (_i238 = 0; _i238 < _size234; ++_i238)
                {
                  int32_t _key239;
                  xfer += iprot->readI32(_key239);
                  std::set<std::string> & _val240 = this->map_int_strset_list[_i233][_key239];
                  {
                    _val240.clear();
                    uint32_t _size241;
                    ::apache::thrift::protocol::TType _etype244;
                    xfer += iprot->readSetBegin(_etype244, _size241);
                    uint32_t _i245;
                    for (_i245 = 0; _i245 < _size241; ++_i245)
                    {
                      std::string _elem246;
                      xfer += iprot->readString(_elem246);
                      _val240.insert(_elem246);
                    }
                    xfer += iprot->readSetEnd();
                  }
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.map_int_strset_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NestedMixedx2::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NestedMixedx2");

  xfer += oprot->writeFieldBegin("int_set_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_SET, static_cast<uint32_t>(this->int_set_list.size()));
    std::vector<std::set<int32_t> > ::const_iterator _iter247;
    for (_iter247 = this->int_set_list.begin(); _iter247 != this->int_set_list.end(); ++_iter247)
    {
      {
        xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*_iter247).size()));
        std::set<int32_t> ::const_iterator _iter248;
        for (_iter248 = (*_iter247).begin(); _iter248 != (*_iter247).end(); ++_iter248)
        {
          xfer += oprot->writeI32((*_iter248));
        }
        xfer += oprot->writeSetEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("map_int_strset", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_SET, static_cast<uint32_t>(this->map_int_strset.size()));
    std::map<int32_t, std::set<std::string> > ::const_iterator _iter249;
    for (_iter249 = this->map_int_strset.begin(); _iter249 != this->map_int_strset.end(); ++_iter249)
    {
      xfer += oprot->writeI32(_iter249->first);
      {
        xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter249->second.size()));
        std::set<std::string> ::const_iterator _iter250;
        for (_iter250 = _iter249->second.begin(); _iter250 != _iter249->second.end(); ++_iter250)
        {
          xfer += oprot->writeString((*_iter250));
        }
        xfer += oprot->writeSetEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("map_int_strset_list", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->map_int_strset_list.size()));
    std::vector<std::map<int32_t, std::set<std::string> > > ::const_iterator _iter251;
    for (_iter251 = this->map_int_strset_list.begin(); _iter251 != this->map_int_strset_list.end(); ++_iter251)
    {
      {
        xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_SET, static_cast<uint32_t>((*_iter251).size()));
        std::map<int32_t, std::set<std::string> > ::const_iterator _iter252;
        for (_iter252 = (*_iter251).begin(); _iter252 != (*_iter251).end(); ++_iter252)
        {
          xfer += oprot->writeI32(_iter252->first);
          {
            xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter252->second.size()));
            std::set<std::string> ::const_iterator _iter253;
            for (_iter253 = _iter252->second.begin(); _iter253 != _iter252->second.end(); ++_iter253)
            {
              xfer += oprot->writeString((*_iter253));
            }
            xfer += oprot->writeSetEnd();
          }
        }
        xfer += oprot->writeMapEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NestedMixedx2 &a, NestedMixedx2 &b) {
  using ::std::swap;
  swap(a.int_set_list, b.int_set_list);
  swap(a.map_int_strset, b.map_int_strset);
  swap(a.map_int_strset_list, b.map_int_strset_list);
  swap(a.__isset, b.__isset);
}

NestedMixedx2::NestedMixedx2(const NestedMixedx2& other254) {
  int_set_list = other254.int_set_list;
  map_int_strset = other254.map_int_strset;
  map_int_strset_list = other254.map_int_strset_list;
  __isset = other254.__isset;
}
NestedMixedx2& NestedMixedx2::operator=(const NestedMixedx2& other255) {
  int_set_list = other255.int_set_list;
  map_int_strset = other255.map_int_strset;
  map_int_strset_list = other255.map_int_strset_list;
  __isset = other255.__isset;
  return *this;
}
void NestedMixedx2::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NestedMixedx2(";
  out << "int_set_list=" << to_string(int_set_list);
  out << ", " << "map_int_strset=" << to_string(map_int_strset);
  out << ", " << "map_int_strset_list=" << to_string(map_int_strset_list);
  out << ")";
}


ListBonks::~ListBonks() throw() {
}


void ListBonks::__set_bonk(const std::vector<Bonk> & val) {
  this->bonk = val;
}
std::ostream& operator<<(std::ostream& out, const ListBonks& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ListBonks::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->bonk.clear();
            uint32_t _size256;
            ::apache::thrift::protocol::TType _etype259;
            xfer += iprot->readListBegin(_etype259, _size256);
            this->bonk.resize(_size256);
            uint32_t _i260;
            for (_i260 = 0; _i260 < _size256; ++_i260)
            {
              xfer += this->bonk[_i260].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.bonk = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ListBonks::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ListBonks");

  xfer += oprot->writeFieldBegin("bonk", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->bonk.size()));
    std::vector<Bonk> ::const_iterator _iter261;
    for (_iter261 = this->bonk.begin(); _iter261 != this->bonk.end(); ++_iter261)
    {
      xfer += (*_iter261).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ListBonks &a, ListBonks &b) {
  using ::std::swap;
  swap(a.bonk, b.bonk);
  swap(a.__isset, b.__isset);
}

ListBonks::ListBonks(const ListBonks& other262) {
  bonk = other262.bonk;
  __isset = other262.__isset;
}
ListBonks& ListBonks::operator=(const ListBonks& other263) {
  bonk = other263.bonk;
  __isset = other263.__isset;
  return *this;
}
void ListBonks::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ListBonks(";
  out << "bonk=" << to_string(bonk);
  out << ")";
}


NestedListsBonk::~NestedListsBonk() throw() {
}


void NestedListsBonk::__set_bonk(const std::vector<std::vector<std::vector<Bonk> > > & val) {
  this->bonk = val;
}
std::ostream& operator<<(std::ostream& out, const NestedListsBonk& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NestedListsBonk::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->bonk.clear();
            uint32_t _size264;
            ::apache::thrift::protocol::TType _etype267;
            xfer += iprot->readListBegin(_etype267, _size264);
            this->bonk.resize(_size264);
            uint32_t _i268;
            for (_i268 = 0; _i268 < _size264; ++_i268)
            {
              {
                this->bonk[_i268].clear();
                uint32_t _size269;
                ::apache::thrift::protocol::TType _etype272;
                xfer += iprot->readListBegin(_etype272, _size269);
                this->bonk[_i268].resize(_size269);
                uint32_t _i273;
                for (_i273 = 0; _i273 < _size269; ++_i273)
                {
                  {
                    this->bonk[_i268][_i273].clear();
                    uint32_t _size274;
                    ::apache::thrift::protocol::TType _etype277;
                    xfer += iprot->readListBegin(_etype277, _size274);
                    this->bonk[_i268][_i273].resize(_size274);
                    uint32_t _i278;
                    for (_i278 = 0; _i278 < _size274; ++_i278)
                    {
                      xfer += this->bonk[_i268][_i273][_i278].read(iprot);
                    }
                    xfer += iprot->readListEnd();
                  }
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.bonk = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NestedListsBonk::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NestedListsBonk");

  xfer += oprot->writeFieldBegin("bonk", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->bonk.size()));
    std::vector<std::vector<std::vector<Bonk> > > ::const_iterator _iter279;
    for (_iter279 = this->bonk.begin(); _iter279 != this->bonk.end(); ++_iter279)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>((*_iter279).size()));
        std::vector<std::vector<Bonk> > ::const_iterator _iter280;
        for (_iter280 = (*_iter279).begin(); _iter280 != (*_iter279).end(); ++_iter280)
        {
          {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*_iter280).size()));
            std::vector<Bonk> ::const_iterator _iter281;
            for (_iter281 = (*_iter280).begin(); _iter281 != (*_iter280).end(); ++_iter281)
            {
              xfer += (*_iter281).write(oprot);
            }
            xfer += oprot->writeListEnd();
          }
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NestedListsBonk &a, NestedListsBonk &b) {
  using ::std::swap;
  swap(a.bonk, b.bonk);
  swap(a.__isset, b.__isset);
}

NestedListsBonk::NestedListsBonk(const NestedListsBonk& other282) {
  bonk = other282.bonk;
  __isset = other282.__isset;
}
NestedListsBonk& NestedListsBonk::operator=(const NestedListsBonk& other283) {
  bonk = other283.bonk;
  __isset = other283.__isset;
  return *this;
}
void NestedListsBonk::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NestedListsBonk(";
  out << "bonk=" << to_string(bonk);
  out << ")";
}


BoolTest::~BoolTest() throw() {
}


void BoolTest::__set_b(const bool val) {
  this->b = val;
__isset.b = true;
}

void BoolTest::__set_s(const std::string& val) {
  this->s = val;
__isset.s = true;
}
std::ostream& operator<<(std::ostream& out, const BoolTest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t BoolTest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->b);
          this->__isset.b = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->s);
          this->__isset.s = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BoolTest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BoolTest");

  if (this->__isset.b) {
    xfer += oprot->writeFieldBegin("b", ::apache::thrift::protocol::T_BOOL, 1);
    xfer += oprot->writeBool(this->b);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.s) {
    xfer += oprot->writeFieldBegin("s", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->s);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BoolTest &a, BoolTest &b) {
  using ::std::swap;
  swap(a.b, b.b);
  swap(a.s, b.s);
  swap(a.__isset, b.__isset);
}

BoolTest::BoolTest(const BoolTest& other284) {
  b = other284.b;
  s = other284.s;
  __isset = other284.__isset;
}
BoolTest& BoolTest::operator=(const BoolTest& other285) {
  b = other285.b;
  s = other285.s;
  __isset = other285.__isset;
  return *this;
}
void BoolTest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BoolTest(";
  out << "b="; (__isset.b ? (out << to_string(b)) : (out << "<null>"));
  out << ", " << "s="; (__isset.s ? (out << to_string(s)) : (out << "<null>"));
  out << ")";
}


StructA::~StructA() throw() {
}


void StructA::__set_s(const std::string& val) {
  this->s = val;
}
std::ostream& operator<<(std::ostream& out, const StructA& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t StructA::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_s = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->s);
          isset_s = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_s)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t StructA::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("StructA");

  xfer += oprot->writeFieldBegin("s", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->s);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(StructA &a, StructA &b) {
  using ::std::swap;
  swap(a.s, b.s);
}

StructA::StructA(const StructA& other286) {
  s = other286.s;
}
StructA& StructA::operator=(const StructA& other287) {
  s = other287.s;
  return *this;
}
void StructA::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "StructA(";
  out << "s=" << to_string(s);
  out << ")";
}


StructB::~StructB() throw() {
}


void StructB::__set_aa(const StructA& val) {
  this->aa = val;
__isset.aa = true;
}

void StructB::__set_ab(const StructA& val) {
  this->ab = val;
}
std::ostream& operator<<(std::ostream& out, const StructB& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t StructB::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_ab = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->aa.read(iprot);
          this->__isset.aa = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ab.read(iprot);
          isset_ab = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_ab)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t StructB::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("StructB");

  if (this->__isset.aa) {
    xfer += oprot->writeFieldBegin("aa", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->aa.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("ab", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->ab.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(StructB &a, StructB &b) {
  using ::std::swap;
  swap(a.aa, b.aa);
  swap(a.ab, b.ab);
  swap(a.__isset, b.__isset);
}

StructB::StructB(const StructB& other288) {
  aa = other288.aa;
  ab = other288.ab;
  __isset = other288.__isset;
}
StructB& StructB::operator=(const StructB& other289) {
  aa = other289.aa;
  ab = other289.ab;
  __isset = other289.__isset;
  return *this;
}
void StructB::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "StructB(";
  out << "aa="; (__isset.aa ? (out << to_string(aa)) : (out << "<null>"));
  out << ", " << "ab=" << to_string(ab);
  out << ")";
}

}} // namespace
